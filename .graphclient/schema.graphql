schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  domain(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Domain
  domains(
    skip: Int = 0
    first: Int = 100
    orderBy: Domain_orderBy
    orderDirection: OrderDirection
    where: Domain_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Domain!]!
  transfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    where: Transfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transfer!]!
  newOwner(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewOwner
  newOwners(
    skip: Int = 0
    first: Int = 100
    orderBy: NewOwner_orderBy
    orderDirection: OrderDirection
    where: NewOwner_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewOwner!]!
  newResolver(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewResolver
  newResolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: NewResolver_orderBy
    orderDirection: OrderDirection
    where: NewResolver_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewResolver!]!
  newTTL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewTTL
  newTTLs(
    skip: Int = 0
    first: Int = 100
    orderBy: NewTTL_orderBy
    orderDirection: OrderDirection
    where: NewTTL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewTTL!]!
  account(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  registration(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Registration
  registrations(
    skip: Int = 0
    first: Int = 100
    orderBy: Registration_orderBy
    orderDirection: OrderDirection
    where: Registration_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Registration!]!
  nameRegistered(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRegistered
  nameRegistereds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRegistered_orderBy
    orderDirection: OrderDirection
    where: NameRegistered_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRegistered!]!
  nameRenewed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRenewed
  nameReneweds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRenewed_orderBy
    orderDirection: OrderDirection
    where: NameRenewed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRenewed!]!
  nameTransferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameTransferred
  nameTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameTransferred_orderBy
    orderDirection: OrderDirection
    where: NameTransferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameTransferred!]!
  resolver(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Resolver
  resolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: Resolver_orderBy
    orderDirection: OrderDirection
    where: Resolver_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Resolver!]!
  addrChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddrChanged
  addrChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AddrChanged_orderBy
    orderDirection: OrderDirection
    where: AddrChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddrChanged!]!
  multicoinAddrChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MulticoinAddrChanged
  multicoinAddrChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: MulticoinAddrChanged_orderBy
    orderDirection: OrderDirection
    where: MulticoinAddrChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MulticoinAddrChanged!]!
  nameChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameChanged
  nameChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameChanged_orderBy
    orderDirection: OrderDirection
    where: NameChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameChanged!]!
  abiChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AbiChanged
  abiChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AbiChanged_orderBy
    orderDirection: OrderDirection
    where: AbiChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AbiChanged!]!
  pubkeyChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PubkeyChanged
  pubkeyChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: PubkeyChanged_orderBy
    orderDirection: OrderDirection
    where: PubkeyChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PubkeyChanged!]!
  textChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TextChanged
  textChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TextChanged_orderBy
    orderDirection: OrderDirection
    where: TextChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TextChanged!]!
  contenthashChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ContenthashChanged
  contenthashChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: ContenthashChanged_orderBy
    orderDirection: OrderDirection
    where: ContenthashChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ContenthashChanged!]!
  interfaceChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InterfaceChanged
  interfaceChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: InterfaceChanged_orderBy
    orderDirection: OrderDirection
    where: InterfaceChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [InterfaceChanged!]!
  authorisationChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuthorisationChanged
  authorisationChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AuthorisationChanged_orderBy
    orderDirection: OrderDirection
    where: AuthorisationChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuthorisationChanged!]!
  domainEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DomainEvent
  domainEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DomainEvent_orderBy
    orderDirection: OrderDirection
    where: DomainEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DomainEvent!]!
  registrationEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RegistrationEvent
  registrationEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RegistrationEvent_orderBy
    orderDirection: OrderDirection
    where: RegistrationEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RegistrationEvent!]!
  resolverEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEvent
  resolverEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEvent_orderBy
    orderDirection: OrderDirection
    where: ResolverEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEvent!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  rewardToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardToken
  rewardTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardToken_orderBy
    orderDirection: OrderDirection
    where: RewardToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardToken!]!
  liquidityPoolFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolFee
  liquidityPoolFees(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolFee_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolFee!]!
  dexAmmProtocol(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DexAmmProtocol
  dexAmmProtocols(
    skip: Int = 0
    first: Int = 100
    orderBy: DexAmmProtocol_orderBy
    orderDirection: OrderDirection
    where: DexAmmProtocol_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DexAmmProtocol!]!
  usageMetricsDailySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UsageMetricsDailySnapshot
  usageMetricsDailySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: UsageMetricsDailySnapshot_orderBy
    orderDirection: OrderDirection
    where: UsageMetricsDailySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UsageMetricsDailySnapshot!]!
  usageMetricsHourlySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UsageMetricsHourlySnapshot
  usageMetricsHourlySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: UsageMetricsHourlySnapshot_orderBy
    orderDirection: OrderDirection
    where: UsageMetricsHourlySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UsageMetricsHourlySnapshot!]!
  financialsDailySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FinancialsDailySnapshot
  financialsDailySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: FinancialsDailySnapshot_orderBy
    orderDirection: OrderDirection
    where: FinancialsDailySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FinancialsDailySnapshot!]!
  liquidityPool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPool!]!
  liquidityPoolDailySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolDailySnapshot
  liquidityPoolDailySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolDailySnapshot_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolDailySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolDailySnapshot!]!
  liquidityPoolHourlySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolHourlySnapshot
  liquidityPoolHourlySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolHourlySnapshot_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolHourlySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolHourlySnapshot!]!
  deposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  withdraw(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdraw
  withdraws(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdraw_orderBy
    orderDirection: OrderDirection
    where: Withdraw_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdraw!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  activeAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ActiveAccount
  activeAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: ActiveAccount_orderBy
    orderDirection: OrderDirection
    where: ActiveAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ActiveAccount!]!
  liquidityPoolAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): _LiquidityPoolAmount
  liquidityPoolAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: _LiquidityPoolAmount_orderBy
    orderDirection: OrderDirection
    where: _LiquidityPoolAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [_LiquidityPoolAmount!]!
  helperStore(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): _HelperStore
  helperStores(
    skip: Int = 0
    first: Int = 100
    orderBy: _HelperStore_orderBy
    orderDirection: OrderDirection
    where: _HelperStore_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [_HelperStore!]!
  tokenWhitelist(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): _TokenWhitelist
  tokenWhitelists(
    skip: Int = 0
    first: Int = 100
    orderBy: _TokenWhitelist_orderBy
    orderDirection: OrderDirection
    where: _TokenWhitelist_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [_TokenWhitelist!]!
  protocol(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Protocol
  protocols(
    skip: Int = 0
    first: Int = 100
    orderBy: Protocol_orderBy
    orderDirection: OrderDirection
    where: Protocol_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Protocol!]!
  event(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!
}

type Subscription {
  domain(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Domain
  domains(
    skip: Int = 0
    first: Int = 100
    orderBy: Domain_orderBy
    orderDirection: OrderDirection
    where: Domain_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Domain!]!
  transfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    where: Transfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transfer!]!
  newOwner(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewOwner
  newOwners(
    skip: Int = 0
    first: Int = 100
    orderBy: NewOwner_orderBy
    orderDirection: OrderDirection
    where: NewOwner_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewOwner!]!
  newResolver(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewResolver
  newResolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: NewResolver_orderBy
    orderDirection: OrderDirection
    where: NewResolver_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewResolver!]!
  newTTL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewTTL
  newTTLs(
    skip: Int = 0
    first: Int = 100
    orderBy: NewTTL_orderBy
    orderDirection: OrderDirection
    where: NewTTL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewTTL!]!
  account(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  registration(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Registration
  registrations(
    skip: Int = 0
    first: Int = 100
    orderBy: Registration_orderBy
    orderDirection: OrderDirection
    where: Registration_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Registration!]!
  nameRegistered(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRegistered
  nameRegistereds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRegistered_orderBy
    orderDirection: OrderDirection
    where: NameRegistered_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRegistered!]!
  nameRenewed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRenewed
  nameReneweds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRenewed_orderBy
    orderDirection: OrderDirection
    where: NameRenewed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRenewed!]!
  nameTransferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameTransferred
  nameTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameTransferred_orderBy
    orderDirection: OrderDirection
    where: NameTransferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameTransferred!]!
  resolver(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Resolver
  resolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: Resolver_orderBy
    orderDirection: OrderDirection
    where: Resolver_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Resolver!]!
  addrChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddrChanged
  addrChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AddrChanged_orderBy
    orderDirection: OrderDirection
    where: AddrChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddrChanged!]!
  multicoinAddrChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MulticoinAddrChanged
  multicoinAddrChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: MulticoinAddrChanged_orderBy
    orderDirection: OrderDirection
    where: MulticoinAddrChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MulticoinAddrChanged!]!
  nameChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameChanged
  nameChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameChanged_orderBy
    orderDirection: OrderDirection
    where: NameChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameChanged!]!
  abiChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AbiChanged
  abiChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AbiChanged_orderBy
    orderDirection: OrderDirection
    where: AbiChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AbiChanged!]!
  pubkeyChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PubkeyChanged
  pubkeyChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: PubkeyChanged_orderBy
    orderDirection: OrderDirection
    where: PubkeyChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PubkeyChanged!]!
  textChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TextChanged
  textChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TextChanged_orderBy
    orderDirection: OrderDirection
    where: TextChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TextChanged!]!
  contenthashChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ContenthashChanged
  contenthashChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: ContenthashChanged_orderBy
    orderDirection: OrderDirection
    where: ContenthashChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ContenthashChanged!]!
  interfaceChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InterfaceChanged
  interfaceChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: InterfaceChanged_orderBy
    orderDirection: OrderDirection
    where: InterfaceChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [InterfaceChanged!]!
  authorisationChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuthorisationChanged
  authorisationChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AuthorisationChanged_orderBy
    orderDirection: OrderDirection
    where: AuthorisationChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuthorisationChanged!]!
  domainEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DomainEvent
  domainEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DomainEvent_orderBy
    orderDirection: OrderDirection
    where: DomainEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DomainEvent!]!
  registrationEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RegistrationEvent
  registrationEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RegistrationEvent_orderBy
    orderDirection: OrderDirection
    where: RegistrationEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RegistrationEvent!]!
  resolverEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEvent
  resolverEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEvent_orderBy
    orderDirection: OrderDirection
    where: ResolverEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEvent!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  rewardToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardToken
  rewardTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardToken_orderBy
    orderDirection: OrderDirection
    where: RewardToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardToken!]!
  liquidityPoolFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolFee
  liquidityPoolFees(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolFee_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolFee!]!
  dexAmmProtocol(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DexAmmProtocol
  dexAmmProtocols(
    skip: Int = 0
    first: Int = 100
    orderBy: DexAmmProtocol_orderBy
    orderDirection: OrderDirection
    where: DexAmmProtocol_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DexAmmProtocol!]!
  usageMetricsDailySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UsageMetricsDailySnapshot
  usageMetricsDailySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: UsageMetricsDailySnapshot_orderBy
    orderDirection: OrderDirection
    where: UsageMetricsDailySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UsageMetricsDailySnapshot!]!
  usageMetricsHourlySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UsageMetricsHourlySnapshot
  usageMetricsHourlySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: UsageMetricsHourlySnapshot_orderBy
    orderDirection: OrderDirection
    where: UsageMetricsHourlySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UsageMetricsHourlySnapshot!]!
  financialsDailySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FinancialsDailySnapshot
  financialsDailySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: FinancialsDailySnapshot_orderBy
    orderDirection: OrderDirection
    where: FinancialsDailySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FinancialsDailySnapshot!]!
  liquidityPool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPool!]!
  liquidityPoolDailySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolDailySnapshot
  liquidityPoolDailySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolDailySnapshot_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolDailySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolDailySnapshot!]!
  liquidityPoolHourlySnapshot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolHourlySnapshot
  liquidityPoolHourlySnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolHourlySnapshot_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolHourlySnapshot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolHourlySnapshot!]!
  deposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  withdraw(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdraw
  withdraws(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdraw_orderBy
    orderDirection: OrderDirection
    where: Withdraw_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdraw!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  activeAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ActiveAccount
  activeAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: ActiveAccount_orderBy
    orderDirection: OrderDirection
    where: ActiveAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ActiveAccount!]!
  liquidityPoolAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): _LiquidityPoolAmount
  liquidityPoolAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: _LiquidityPoolAmount_orderBy
    orderDirection: OrderDirection
    where: _LiquidityPoolAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [_LiquidityPoolAmount!]!
  helperStore(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): _HelperStore
  helperStores(
    skip: Int = 0
    first: Int = 100
    orderBy: _HelperStore_orderBy
    orderDirection: OrderDirection
    where: _HelperStore_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [_HelperStore!]!
  tokenWhitelist(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): _TokenWhitelist
  tokenWhitelists(
    skip: Int = 0
    first: Int = 100
    orderBy: _TokenWhitelist_orderBy
    orderDirection: OrderDirection
    where: _TokenWhitelist_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [_TokenWhitelist!]!
  protocol(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Protocol
  protocols(
    skip: Int = 0
    first: Int = 100
    orderBy: Protocol_orderBy
    orderDirection: OrderDirection
    where: Protocol_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Protocol!]!
  event(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!
}

type AbiChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  contentType: BigInt!
}

input AbiChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  contentType: BigInt
  contentType_not: BigInt
  contentType_gt: BigInt
  contentType_lt: BigInt
  contentType_gte: BigInt
  contentType_lte: BigInt
  contentType_in: [BigInt!]
  contentType_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AbiChanged_filter]
  or: [AbiChanged_filter]
}

enum AbiChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  contentType
}

type Account {
  """ Address of the account """
  id: ID!
  domains(skip: Int = 0, first: Int = 100, orderBy: Domain_orderBy, orderDirection: OrderDirection, where: Domain_filter): [Domain!]!
  registrations(skip: Int = 0, first: Int = 100, orderBy: Registration_orderBy, orderDirection: OrderDirection, where: Registration_filter): [Registration!]
}

input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domains_: Domain_filter
  registrations_: Registration_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  or: [Account_filter]
}

enum Account_orderBy {
  id
  domains
  registrations
}

type AddrChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  addr: Account!
}

input AddrChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  addr: String
  addr_not: String
  addr_gt: String
  addr_lt: String
  addr_gte: String
  addr_lte: String
  addr_in: [String!]
  addr_not_in: [String!]
  addr_contains: String
  addr_contains_nocase: String
  addr_not_contains: String
  addr_not_contains_nocase: String
  addr_starts_with: String
  addr_starts_with_nocase: String
  addr_not_starts_with: String
  addr_not_starts_with_nocase: String
  addr_ends_with: String
  addr_ends_with_nocase: String
  addr_not_ends_with: String
  addr_not_ends_with_nocase: String
  addr_: Account_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AddrChanged_filter]
  or: [AddrChanged_filter]
}

enum AddrChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  addr
  addr__id
}

type AuthorisationChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  owner: Bytes!
  target: Bytes!
  isAuthorized: Boolean!
}

input AuthorisationChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  target: Bytes
  target_not: Bytes
  target_gt: Bytes
  target_lt: Bytes
  target_gte: Bytes
  target_lte: Bytes
  target_in: [Bytes!]
  target_not_in: [Bytes!]
  target_contains: Bytes
  target_not_contains: Bytes
  isAuthorized: Boolean
  isAuthorized_not: Boolean
  isAuthorized_in: [Boolean!]
  isAuthorized_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AuthorisationChanged_filter]
  or: [AuthorisationChanged_filter]
}

enum AuthorisationChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  owner
  target
  isAuthorized
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type ContenthashChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  hash: Bytes!
}

input ContenthashChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  hash: Bytes
  hash_not: Bytes
  hash_gt: Bytes
  hash_lt: Bytes
  hash_gte: Bytes
  hash_lte: Bytes
  hash_in: [Bytes!]
  hash_not_in: [Bytes!]
  hash_contains: Bytes
  hash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ContenthashChanged_filter]
  or: [ContenthashChanged_filter]
}

enum ContenthashChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  hash
}

type Domain {
  id: ID!
  name: String
  labelName: String
  labelhash: Bytes
  parent: Domain
  subdomains(skip: Int = 0, first: Int = 100, orderBy: Domain_orderBy, orderDirection: OrderDirection, where: Domain_filter): [Domain!]!
  resolvedAddress: Account
  owner: Account!
  resolver: Resolver
  ttl: BigInt
  isMigrated: Boolean!
  createdAt: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: DomainEvent_orderBy, orderDirection: OrderDirection, where: DomainEvent_filter): [DomainEvent!]!
}

interface DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  transactionID: Bytes!
}

input DomainEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DomainEvent_filter]
  or: [DomainEvent_filter]
}

enum DomainEvent_orderBy {
  id
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  blockNumber
  transactionID
}

input Domain_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  labelName: String
  labelName_not: String
  labelName_gt: String
  labelName_lt: String
  labelName_gte: String
  labelName_lte: String
  labelName_in: [String!]
  labelName_not_in: [String!]
  labelName_contains: String
  labelName_contains_nocase: String
  labelName_not_contains: String
  labelName_not_contains_nocase: String
  labelName_starts_with: String
  labelName_starts_with_nocase: String
  labelName_not_starts_with: String
  labelName_not_starts_with_nocase: String
  labelName_ends_with: String
  labelName_ends_with_nocase: String
  labelName_not_ends_with: String
  labelName_not_ends_with_nocase: String
  labelhash: Bytes
  labelhash_not: Bytes
  labelhash_gt: Bytes
  labelhash_lt: Bytes
  labelhash_gte: Bytes
  labelhash_lte: Bytes
  labelhash_in: [Bytes!]
  labelhash_not_in: [Bytes!]
  labelhash_contains: Bytes
  labelhash_not_contains: Bytes
  parent: String
  parent_not: String
  parent_gt: String
  parent_lt: String
  parent_gte: String
  parent_lte: String
  parent_in: [String!]
  parent_not_in: [String!]
  parent_contains: String
  parent_contains_nocase: String
  parent_not_contains: String
  parent_not_contains_nocase: String
  parent_starts_with: String
  parent_starts_with_nocase: String
  parent_not_starts_with: String
  parent_not_starts_with_nocase: String
  parent_ends_with: String
  parent_ends_with_nocase: String
  parent_not_ends_with: String
  parent_not_ends_with_nocase: String
  parent_: Domain_filter
  subdomains_: Domain_filter
  resolvedAddress: String
  resolvedAddress_not: String
  resolvedAddress_gt: String
  resolvedAddress_lt: String
  resolvedAddress_gte: String
  resolvedAddress_lte: String
  resolvedAddress_in: [String!]
  resolvedAddress_not_in: [String!]
  resolvedAddress_contains: String
  resolvedAddress_contains_nocase: String
  resolvedAddress_not_contains: String
  resolvedAddress_not_contains_nocase: String
  resolvedAddress_starts_with: String
  resolvedAddress_starts_with_nocase: String
  resolvedAddress_not_starts_with: String
  resolvedAddress_not_starts_with_nocase: String
  resolvedAddress_ends_with: String
  resolvedAddress_ends_with_nocase: String
  resolvedAddress_not_ends_with: String
  resolvedAddress_not_ends_with_nocase: String
  resolvedAddress_: Account_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  ttl: BigInt
  ttl_not: BigInt
  ttl_gt: BigInt
  ttl_lt: BigInt
  ttl_gte: BigInt
  ttl_lte: BigInt
  ttl_in: [BigInt!]
  ttl_not_in: [BigInt!]
  isMigrated: Boolean
  isMigrated_not: Boolean
  isMigrated_in: [Boolean!]
  isMigrated_not_in: [Boolean!]
  createdAt: BigInt
  createdAt_not: BigInt
  createdAt_gt: BigInt
  createdAt_lt: BigInt
  createdAt_gte: BigInt
  createdAt_lte: BigInt
  createdAt_in: [BigInt!]
  createdAt_not_in: [BigInt!]
  events_: DomainEvent_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Domain_filter]
  or: [Domain_filter]
}

enum Domain_orderBy {
  id
  name
  labelName
  labelhash
  parent
  parent__id
  parent__name
  parent__labelName
  parent__labelhash
  parent__ttl
  parent__isMigrated
  parent__createdAt
  subdomains
  resolvedAddress
  resolvedAddress__id
  owner
  owner__id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  ttl
  isMigrated
  createdAt
  events
}

"""
8 bytes signed integer

"""
scalar Int8

type InterfaceChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  interfaceID: Bytes!
  implementer: Bytes!
}

input InterfaceChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  interfaceID: Bytes
  interfaceID_not: Bytes
  interfaceID_gt: Bytes
  interfaceID_lt: Bytes
  interfaceID_gte: Bytes
  interfaceID_lte: Bytes
  interfaceID_in: [Bytes!]
  interfaceID_not_in: [Bytes!]
  interfaceID_contains: Bytes
  interfaceID_not_contains: Bytes
  implementer: Bytes
  implementer_not: Bytes
  implementer_gt: Bytes
  implementer_lt: Bytes
  implementer_gte: Bytes
  implementer_lte: Bytes
  implementer_in: [Bytes!]
  implementer_not_in: [Bytes!]
  implementer_contains: Bytes
  implementer_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [InterfaceChanged_filter]
  or: [InterfaceChanged_filter]
}

enum InterfaceChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  interfaceID
  implementer
}

type MulticoinAddrChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  coinType: Int!
  addr: Bytes!
}

input MulticoinAddrChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  coinType: Int
  coinType_not: Int
  coinType_gt: Int
  coinType_lt: Int
  coinType_gte: Int
  coinType_lte: Int
  coinType_in: [Int!]
  coinType_not_in: [Int!]
  addr: Bytes
  addr_not: Bytes
  addr_gt: Bytes
  addr_lt: Bytes
  addr_gte: Bytes
  addr_lte: Bytes
  addr_in: [Bytes!]
  addr_not_in: [Bytes!]
  addr_contains: Bytes
  addr_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MulticoinAddrChanged_filter]
  or: [MulticoinAddrChanged_filter]
}

enum MulticoinAddrChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  coinType
  addr
}

type NameChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  name: String!
}

input NameChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NameChanged_filter]
  or: [NameChanged_filter]
}

enum NameChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  name
}

type NameRegistered implements RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  transactionID: Bytes!
  registrant: Account!
  expiryDate: BigInt!
}

input NameRegistered_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  registrant: String
  registrant_not: String
  registrant_gt: String
  registrant_lt: String
  registrant_gte: String
  registrant_lte: String
  registrant_in: [String!]
  registrant_not_in: [String!]
  registrant_contains: String
  registrant_contains_nocase: String
  registrant_not_contains: String
  registrant_not_contains_nocase: String
  registrant_starts_with: String
  registrant_starts_with_nocase: String
  registrant_not_starts_with: String
  registrant_not_starts_with_nocase: String
  registrant_ends_with: String
  registrant_ends_with_nocase: String
  registrant_not_ends_with: String
  registrant_not_ends_with_nocase: String
  registrant_: Account_filter
  expiryDate: BigInt
  expiryDate_not: BigInt
  expiryDate_gt: BigInt
  expiryDate_lt: BigInt
  expiryDate_gte: BigInt
  expiryDate_lte: BigInt
  expiryDate_in: [BigInt!]
  expiryDate_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NameRegistered_filter]
  or: [NameRegistered_filter]
}

enum NameRegistered_orderBy {
  id
  registration
  registration__id
  registration__registrationDate
  registration__expiryDate
  registration__cost
  registration__labelName
  blockNumber
  transactionID
  registrant
  registrant__id
  expiryDate
}

type NameRenewed implements RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  transactionID: Bytes!
  expiryDate: BigInt!
}

input NameRenewed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  expiryDate: BigInt
  expiryDate_not: BigInt
  expiryDate_gt: BigInt
  expiryDate_lt: BigInt
  expiryDate_gte: BigInt
  expiryDate_lte: BigInt
  expiryDate_in: [BigInt!]
  expiryDate_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NameRenewed_filter]
  or: [NameRenewed_filter]
}

enum NameRenewed_orderBy {
  id
  registration
  registration__id
  registration__registrationDate
  registration__expiryDate
  registration__cost
  registration__labelName
  blockNumber
  transactionID
  expiryDate
}

type NameTransferred implements RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  transactionID: Bytes!
  newOwner: Account!
}

input NameTransferred_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  newOwner: String
  newOwner_not: String
  newOwner_gt: String
  newOwner_lt: String
  newOwner_gte: String
  newOwner_lte: String
  newOwner_in: [String!]
  newOwner_not_in: [String!]
  newOwner_contains: String
  newOwner_contains_nocase: String
  newOwner_not_contains: String
  newOwner_not_contains_nocase: String
  newOwner_starts_with: String
  newOwner_starts_with_nocase: String
  newOwner_not_starts_with: String
  newOwner_not_starts_with_nocase: String
  newOwner_ends_with: String
  newOwner_ends_with_nocase: String
  newOwner_not_ends_with: String
  newOwner_not_ends_with_nocase: String
  newOwner_: Account_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NameTransferred_filter]
  or: [NameTransferred_filter]
}

enum NameTransferred_orderBy {
  id
  registration
  registration__id
  registration__registrationDate
  registration__expiryDate
  registration__cost
  registration__labelName
  blockNumber
  transactionID
  newOwner
  newOwner__id
}

type NewOwner implements DomainEvent {
  id: ID!
  parentDomain: Domain!
  domain: Domain!
  blockNumber: Int!
  transactionID: Bytes!
  owner: Account!
}

input NewOwner_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  parentDomain: String
  parentDomain_not: String
  parentDomain_gt: String
  parentDomain_lt: String
  parentDomain_gte: String
  parentDomain_lte: String
  parentDomain_in: [String!]
  parentDomain_not_in: [String!]
  parentDomain_contains: String
  parentDomain_contains_nocase: String
  parentDomain_not_contains: String
  parentDomain_not_contains_nocase: String
  parentDomain_starts_with: String
  parentDomain_starts_with_nocase: String
  parentDomain_not_starts_with: String
  parentDomain_not_starts_with_nocase: String
  parentDomain_ends_with: String
  parentDomain_ends_with_nocase: String
  parentDomain_not_ends_with: String
  parentDomain_not_ends_with_nocase: String
  parentDomain_: Domain_filter
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NewOwner_filter]
  or: [NewOwner_filter]
}

enum NewOwner_orderBy {
  id
  parentDomain
  parentDomain__id
  parentDomain__name
  parentDomain__labelName
  parentDomain__labelhash
  parentDomain__ttl
  parentDomain__isMigrated
  parentDomain__createdAt
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  blockNumber
  transactionID
  owner
  owner__id
}

type NewResolver implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  transactionID: Bytes!
  resolver: Resolver!
}

input NewResolver_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NewResolver_filter]
  or: [NewResolver_filter]
}

enum NewResolver_orderBy {
  id
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  blockNumber
  transactionID
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
}

type NewTTL implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  transactionID: Bytes!
  ttl: BigInt!
}

input NewTTL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  ttl: BigInt
  ttl_not: BigInt
  ttl_gt: BigInt
  ttl_lt: BigInt
  ttl_gte: BigInt
  ttl_lte: BigInt
  ttl_in: [BigInt!]
  ttl_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NewTTL_filter]
  or: [NewTTL_filter]
}

enum NewTTL_orderBy {
  id
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  blockNumber
  transactionID
  ttl
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PubkeyChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  x: Bytes!
  y: Bytes!
}

input PubkeyChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  x: Bytes
  x_not: Bytes
  x_gt: Bytes
  x_lt: Bytes
  x_gte: Bytes
  x_lte: Bytes
  x_in: [Bytes!]
  x_not_in: [Bytes!]
  x_contains: Bytes
  x_not_contains: Bytes
  y: Bytes
  y_not: Bytes
  y_gt: Bytes
  y_lt: Bytes
  y_gte: Bytes
  y_lte: Bytes
  y_in: [Bytes!]
  y_not_in: [Bytes!]
  y_contains: Bytes
  y_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PubkeyChanged_filter]
  or: [PubkeyChanged_filter]
}

enum PubkeyChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  x
  y
}

type Registration {
  id: ID!
  domain: Domain
  registrationDate: BigInt!
  expiryDate: BigInt!
  cost: BigInt
  registrant: Account!
  labelName: String
  events(skip: Int = 0, first: Int = 100, orderBy: RegistrationEvent_orderBy, orderDirection: OrderDirection, where: RegistrationEvent_filter): [RegistrationEvent!]!
}

interface RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  transactionID: Bytes!
}

input RegistrationEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RegistrationEvent_filter]
  or: [RegistrationEvent_filter]
}

enum RegistrationEvent_orderBy {
  id
  registration
  registration__id
  registration__registrationDate
  registration__expiryDate
  registration__cost
  registration__labelName
  blockNumber
  transactionID
}

input Registration_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  registrationDate: BigInt
  registrationDate_not: BigInt
  registrationDate_gt: BigInt
  registrationDate_lt: BigInt
  registrationDate_gte: BigInt
  registrationDate_lte: BigInt
  registrationDate_in: [BigInt!]
  registrationDate_not_in: [BigInt!]
  expiryDate: BigInt
  expiryDate_not: BigInt
  expiryDate_gt: BigInt
  expiryDate_lt: BigInt
  expiryDate_gte: BigInt
  expiryDate_lte: BigInt
  expiryDate_in: [BigInt!]
  expiryDate_not_in: [BigInt!]
  cost: BigInt
  cost_not: BigInt
  cost_gt: BigInt
  cost_lt: BigInt
  cost_gte: BigInt
  cost_lte: BigInt
  cost_in: [BigInt!]
  cost_not_in: [BigInt!]
  registrant: String
  registrant_not: String
  registrant_gt: String
  registrant_lt: String
  registrant_gte: String
  registrant_lte: String
  registrant_in: [String!]
  registrant_not_in: [String!]
  registrant_contains: String
  registrant_contains_nocase: String
  registrant_not_contains: String
  registrant_not_contains_nocase: String
  registrant_starts_with: String
  registrant_starts_with_nocase: String
  registrant_not_starts_with: String
  registrant_not_starts_with_nocase: String
  registrant_ends_with: String
  registrant_ends_with_nocase: String
  registrant_not_ends_with: String
  registrant_not_ends_with_nocase: String
  registrant_: Account_filter
  labelName: String
  labelName_not: String
  labelName_gt: String
  labelName_lt: String
  labelName_gte: String
  labelName_lte: String
  labelName_in: [String!]
  labelName_not_in: [String!]
  labelName_contains: String
  labelName_contains_nocase: String
  labelName_not_contains: String
  labelName_not_contains_nocase: String
  labelName_starts_with: String
  labelName_starts_with_nocase: String
  labelName_not_starts_with: String
  labelName_not_starts_with_nocase: String
  labelName_ends_with: String
  labelName_ends_with_nocase: String
  labelName_not_ends_with: String
  labelName_not_ends_with_nocase: String
  events_: RegistrationEvent_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Registration_filter]
  or: [Registration_filter]
}

enum Registration_orderBy {
  id
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  registrationDate
  expiryDate
  cost
  registrant
  registrant__id
  labelName
  events
}

type Resolver {
  id: ID!
  domain: Domain
  address: Bytes!
  addr: Account
  contentHash: Bytes
  texts: [String!]
  coinTypes: [Int!]
  events(skip: Int = 0, first: Int = 100, orderBy: ResolverEvent_orderBy, orderDirection: OrderDirection, where: ResolverEvent_filter): [ResolverEvent!]!
}

interface ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
}

input ResolverEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ResolverEvent_filter]
  or: [ResolverEvent_filter]
}

enum ResolverEvent_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
}

input Resolver_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  addr: String
  addr_not: String
  addr_gt: String
  addr_lt: String
  addr_gte: String
  addr_lte: String
  addr_in: [String!]
  addr_not_in: [String!]
  addr_contains: String
  addr_contains_nocase: String
  addr_not_contains: String
  addr_not_contains_nocase: String
  addr_starts_with: String
  addr_starts_with_nocase: String
  addr_not_starts_with: String
  addr_not_starts_with_nocase: String
  addr_ends_with: String
  addr_ends_with_nocase: String
  addr_not_ends_with: String
  addr_not_ends_with_nocase: String
  addr_: Account_filter
  contentHash: Bytes
  contentHash_not: Bytes
  contentHash_gt: Bytes
  contentHash_lt: Bytes
  contentHash_gte: Bytes
  contentHash_lte: Bytes
  contentHash_in: [Bytes!]
  contentHash_not_in: [Bytes!]
  contentHash_contains: Bytes
  contentHash_not_contains: Bytes
  texts: [String!]
  texts_not: [String!]
  texts_contains: [String!]
  texts_contains_nocase: [String!]
  texts_not_contains: [String!]
  texts_not_contains_nocase: [String!]
  coinTypes: [Int!]
  coinTypes_not: [Int!]
  coinTypes_contains: [Int!]
  coinTypes_contains_nocase: [Int!]
  coinTypes_not_contains: [Int!]
  coinTypes_not_contains_nocase: [Int!]
  events_: ResolverEvent_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Resolver_filter]
  or: [Resolver_filter]
}

enum Resolver_orderBy {
  id
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  address
  addr
  addr__id
  contentHash
  texts
  coinTypes
  events
}

type TextChanged implements ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  transactionID: Bytes!
  key: String!
}

input TextChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  key: String
  key_not: String
  key_gt: String
  key_lt: String
  key_gte: String
  key_lte: String
  key_in: [String!]
  key_not_in: [String!]
  key_contains: String
  key_contains_nocase: String
  key_not_contains: String
  key_not_contains_nocase: String
  key_starts_with: String
  key_starts_with_nocase: String
  key_not_starts_with: String
  key_not_starts_with_nocase: String
  key_ends_with: String
  key_ends_with_nocase: String
  key_not_ends_with: String
  key_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TextChanged_filter]
  or: [TextChanged_filter]
}

enum TextChanged_orderBy {
  id
  resolver
  resolver__id
  resolver__address
  resolver__contentHash
  blockNumber
  transactionID
  key
}

type Transfer implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  transactionID: Bytes!
  owner: Account!
}

input Transfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_gt: Bytes
  transactionID_lt: Bytes
  transactionID_gte: Bytes
  transactionID_lte: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Transfer_filter]
  or: [Transfer_filter]
}

enum Transfer_orderBy {
  id
  domain
  domain__id
  domain__name
  domain__labelName
  domain__labelhash
  domain__ttl
  domain__isMigrated
  domain__createdAt
  blockNumber
  transactionID
  owner
  owner__id
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type ActiveAccount {
  """ { Address of the account }-{ Days since Unix epoch }-{ [Optional] HH: hour of the day } 
  """
  id: ID!
}

input ActiveAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ActiveAccount_filter]
  or: [ActiveAccount_filter]
}

enum ActiveAccount_orderBy {
  id
}

type Deposit implements Event {
  """ deposit-{ Transaction hash }-{ Log index } """
  id: ID!
  """ Transaction hash of the transaction that emitted this event """
  hash: String!
  """ Event log index. For transactions that don't emit event, create arbitrary index starting from 0 
  """
  logIndex: Int!
  """ The protocol this transaction belongs to """
  protocol: DexAmmProtocol!
  """ Address that received the tokens """
  to: String!
  """ Address that sent the tokens """
  from: String!
  """ Block number of this event """
  blockNumber: BigInt!
  """ Timestamp of this event """
  timestamp: BigInt!
  """ Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool """
  inputTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """ Output token of the pool. E.g. the UNI-LP token """
  outputToken: Token
  """ Amount of input tokens in the token's native unit """
  inputTokenAmounts: [BigInt!]!
  """ Amount of output tokens in the token's native unit """
  outputTokenAmount: BigInt
  """ USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) 
  """
  amountUSD: BigDecimal!
  """ The pool involving this transaction """
  pool: LiquidityPool!
}

input Deposit_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_gt: String
  hash_lt: String
  hash_gte: String
  hash_lte: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_contains_nocase: String
  hash_not_contains: String
  hash_not_contains_nocase: String
  hash_starts_with: String
  hash_starts_with_nocase: String
  hash_not_starts_with: String
  hash_not_starts_with_nocase: String
  hash_ends_with: String
  hash_ends_with_nocase: String
  hash_not_ends_with: String
  hash_not_ends_with_nocase: String
  logIndex: Int
  logIndex_not: Int
  logIndex_gt: Int
  logIndex_lt: Int
  logIndex_gte: Int
  logIndex_lte: Int
  logIndex_in: [Int!]
  logIndex_not_in: [Int!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  inputTokens: [String!]
  inputTokens_not: [String!]
  inputTokens_contains: [String!]
  inputTokens_contains_nocase: [String!]
  inputTokens_not_contains: [String!]
  inputTokens_not_contains_nocase: [String!]
  inputTokens_: Token_filter
  outputToken: String
  outputToken_not: String
  outputToken_gt: String
  outputToken_lt: String
  outputToken_gte: String
  outputToken_lte: String
  outputToken_in: [String!]
  outputToken_not_in: [String!]
  outputToken_contains: String
  outputToken_contains_nocase: String
  outputToken_not_contains: String
  outputToken_not_contains_nocase: String
  outputToken_starts_with: String
  outputToken_starts_with_nocase: String
  outputToken_not_starts_with: String
  outputToken_not_starts_with_nocase: String
  outputToken_ends_with: String
  outputToken_ends_with_nocase: String
  outputToken_not_ends_with: String
  outputToken_not_ends_with_nocase: String
  outputToken_: Token_filter
  inputTokenAmounts: [BigInt!]
  inputTokenAmounts_not: [BigInt!]
  inputTokenAmounts_contains: [BigInt!]
  inputTokenAmounts_contains_nocase: [BigInt!]
  inputTokenAmounts_not_contains: [BigInt!]
  inputTokenAmounts_not_contains_nocase: [BigInt!]
  outputTokenAmount: BigInt
  outputTokenAmount_not: BigInt
  outputTokenAmount_gt: BigInt
  outputTokenAmount_lt: BigInt
  outputTokenAmount_gte: BigInt
  outputTokenAmount_lte: BigInt
  outputTokenAmount_in: [BigInt!]
  outputTokenAmount_not_in: [BigInt!]
  amountUSD: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_lt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_not_in: [BigDecimal!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: LiquidityPool_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Deposit_filter]
  or: [Deposit_filter]
}

enum Deposit_orderBy {
  id
  hash
  logIndex
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  to
  from
  blockNumber
  timestamp
  inputTokens
  outputToken
  outputToken__id
  outputToken__name
  outputToken__symbol
  outputToken__decimals
  outputToken__lastPriceUSD
  outputToken__lastPriceBlockNumber
  inputTokenAmounts
  outputTokenAmount
  amountUSD
  pool
  pool__id
  pool__name
  pool__symbol
  pool__isSingleSided
  pool__createdTimestamp
  pool__createdBlockNumber
  pool__totalValueLockedUSD
  pool__cumulativeSupplySideRevenueUSD
  pool__cumulativeProtocolSideRevenueUSD
  pool__cumulativeTotalRevenueUSD
  pool__cumulativeVolumeUSD
  pool__outputTokenSupply
  pool__outputTokenPriceUSD
  pool__stakedOutputTokenAmount
}

type DexAmmProtocol implements Protocol {
  """ Smart contract address of the protocol's main contract (Factory, Registry, etc) 
  """
  id: ID!
  """ Name of the protocol, including version. e.g. Uniswap v3 """
  name: String!
  """ Slug of protocol, including version. e.g. uniswap-v3 """
  slug: String!
  """ Version of the subgraph schema, in SemVer format (e.g. 1.0.0) """
  schemaVersion: String!
  """ Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) 
  """
  subgraphVersion: String!
  """ Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) 
  """
  methodologyVersion: String!
  """ The blockchain network this subgraph is indexing on """
  network: Network!
  """ The type of protocol (e.g. DEX, Lending, Yield, etc) """
  type: ProtocolType!
  """ Current TVL (Total Value Locked) of the entire protocol """
  totalValueLockedUSD: BigDecimal!
  """ Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. 
  """
  protocolControlledValueUSD: BigDecimal
  """ All historical volume in USD """
  cumulativeVolumeUSD: BigDecimal!
  """ Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. 
  """
  cumulativeSupplySideRevenueUSD: BigDecimal!
  """ Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. 
  """
  cumulativeProtocolSideRevenueUSD: BigDecimal!
  """ All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. 
  """
  cumulativeTotalRevenueUSD: BigDecimal!
  """ Number of cumulative unique users """
  cumulativeUniqueUsers: Int!
  """ Total number of pools """
  totalPoolCount: Int!
  """ This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis 
  """
  _regenesis: Boolean!
  """ Daily usage metrics for this protocol """
  dailyUsageMetrics(skip: Int = 0, first: Int = 100, orderBy: UsageMetricsDailySnapshot_orderBy, orderDirection: OrderDirection, where: UsageMetricsDailySnapshot_filter): [UsageMetricsDailySnapshot!]!
  """ Hourly usage metrics for this protocol """
  hourlyUsageMetrics(skip: Int = 0, first: Int = 100, orderBy: UsageMetricsHourlySnapshot_orderBy, orderDirection: OrderDirection, where: UsageMetricsHourlySnapshot_filter): [UsageMetricsHourlySnapshot!]!
  """ Daily financial metrics for this protocol """
  financialMetrics(skip: Int = 0, first: Int = 100, orderBy: FinancialsDailySnapshot_orderBy, orderDirection: OrderDirection, where: FinancialsDailySnapshot_filter): [FinancialsDailySnapshot!]!
  """ All pools that belong to this protocol """
  pools(skip: Int = 0, first: Int = 100, orderBy: LiquidityPool_orderBy, orderDirection: OrderDirection, where: LiquidityPool_filter): [LiquidityPool!]!
}

input DexAmmProtocol_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  slug: String
  slug_not: String
  slug_gt: String
  slug_lt: String
  slug_gte: String
  slug_lte: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_contains: String
  slug_contains_nocase: String
  slug_not_contains: String
  slug_not_contains_nocase: String
  slug_starts_with: String
  slug_starts_with_nocase: String
  slug_not_starts_with: String
  slug_not_starts_with_nocase: String
  slug_ends_with: String
  slug_ends_with_nocase: String
  slug_not_ends_with: String
  slug_not_ends_with_nocase: String
  schemaVersion: String
  schemaVersion_not: String
  schemaVersion_gt: String
  schemaVersion_lt: String
  schemaVersion_gte: String
  schemaVersion_lte: String
  schemaVersion_in: [String!]
  schemaVersion_not_in: [String!]
  schemaVersion_contains: String
  schemaVersion_contains_nocase: String
  schemaVersion_not_contains: String
  schemaVersion_not_contains_nocase: String
  schemaVersion_starts_with: String
  schemaVersion_starts_with_nocase: String
  schemaVersion_not_starts_with: String
  schemaVersion_not_starts_with_nocase: String
  schemaVersion_ends_with: String
  schemaVersion_ends_with_nocase: String
  schemaVersion_not_ends_with: String
  schemaVersion_not_ends_with_nocase: String
  subgraphVersion: String
  subgraphVersion_not: String
  subgraphVersion_gt: String
  subgraphVersion_lt: String
  subgraphVersion_gte: String
  subgraphVersion_lte: String
  subgraphVersion_in: [String!]
  subgraphVersion_not_in: [String!]
  subgraphVersion_contains: String
  subgraphVersion_contains_nocase: String
  subgraphVersion_not_contains: String
  subgraphVersion_not_contains_nocase: String
  subgraphVersion_starts_with: String
  subgraphVersion_starts_with_nocase: String
  subgraphVersion_not_starts_with: String
  subgraphVersion_not_starts_with_nocase: String
  subgraphVersion_ends_with: String
  subgraphVersion_ends_with_nocase: String
  subgraphVersion_not_ends_with: String
  subgraphVersion_not_ends_with_nocase: String
  methodologyVersion: String
  methodologyVersion_not: String
  methodologyVersion_gt: String
  methodologyVersion_lt: String
  methodologyVersion_gte: String
  methodologyVersion_lte: String
  methodologyVersion_in: [String!]
  methodologyVersion_not_in: [String!]
  methodologyVersion_contains: String
  methodologyVersion_contains_nocase: String
  methodologyVersion_not_contains: String
  methodologyVersion_not_contains_nocase: String
  methodologyVersion_starts_with: String
  methodologyVersion_starts_with_nocase: String
  methodologyVersion_not_starts_with: String
  methodologyVersion_not_starts_with_nocase: String
  methodologyVersion_ends_with: String
  methodologyVersion_ends_with_nocase: String
  methodologyVersion_not_ends_with: String
  methodologyVersion_not_ends_with_nocase: String
  network: Network
  network_not: Network
  network_in: [Network!]
  network_not_in: [Network!]
  type: ProtocolType
  type_not: ProtocolType
  type_in: [ProtocolType!]
  type_not_in: [ProtocolType!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_not_in: [BigDecimal!]
  protocolControlledValueUSD: BigDecimal
  protocolControlledValueUSD_not: BigDecimal
  protocolControlledValueUSD_gt: BigDecimal
  protocolControlledValueUSD_lt: BigDecimal
  protocolControlledValueUSD_gte: BigDecimal
  protocolControlledValueUSD_lte: BigDecimal
  protocolControlledValueUSD_in: [BigDecimal!]
  protocolControlledValueUSD_not_in: [BigDecimal!]
  cumulativeVolumeUSD: BigDecimal
  cumulativeVolumeUSD_not: BigDecimal
  cumulativeVolumeUSD_gt: BigDecimal
  cumulativeVolumeUSD_lt: BigDecimal
  cumulativeVolumeUSD_gte: BigDecimal
  cumulativeVolumeUSD_lte: BigDecimal
  cumulativeVolumeUSD_in: [BigDecimal!]
  cumulativeVolumeUSD_not_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD: BigDecimal
  cumulativeSupplySideRevenueUSD_not: BigDecimal
  cumulativeSupplySideRevenueUSD_gt: BigDecimal
  cumulativeSupplySideRevenueUSD_lt: BigDecimal
  cumulativeSupplySideRevenueUSD_gte: BigDecimal
  cumulativeSupplySideRevenueUSD_lte: BigDecimal
  cumulativeSupplySideRevenueUSD_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD_not_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD: BigDecimal
  cumulativeProtocolSideRevenueUSD_not: BigDecimal
  cumulativeProtocolSideRevenueUSD_gt: BigDecimal
  cumulativeProtocolSideRevenueUSD_lt: BigDecimal
  cumulativeProtocolSideRevenueUSD_gte: BigDecimal
  cumulativeProtocolSideRevenueUSD_lte: BigDecimal
  cumulativeProtocolSideRevenueUSD_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD_not_in: [BigDecimal!]
  cumulativeTotalRevenueUSD: BigDecimal
  cumulativeTotalRevenueUSD_not: BigDecimal
  cumulativeTotalRevenueUSD_gt: BigDecimal
  cumulativeTotalRevenueUSD_lt: BigDecimal
  cumulativeTotalRevenueUSD_gte: BigDecimal
  cumulativeTotalRevenueUSD_lte: BigDecimal
  cumulativeTotalRevenueUSD_in: [BigDecimal!]
  cumulativeTotalRevenueUSD_not_in: [BigDecimal!]
  cumulativeUniqueUsers: Int
  cumulativeUniqueUsers_not: Int
  cumulativeUniqueUsers_gt: Int
  cumulativeUniqueUsers_lt: Int
  cumulativeUniqueUsers_gte: Int
  cumulativeUniqueUsers_lte: Int
  cumulativeUniqueUsers_in: [Int!]
  cumulativeUniqueUsers_not_in: [Int!]
  totalPoolCount: Int
  totalPoolCount_not: Int
  totalPoolCount_gt: Int
  totalPoolCount_lt: Int
  totalPoolCount_gte: Int
  totalPoolCount_lte: Int
  totalPoolCount_in: [Int!]
  totalPoolCount_not_in: [Int!]
  _regenesis: Boolean
  _regenesis_not: Boolean
  _regenesis_in: [Boolean!]
  _regenesis_not_in: [Boolean!]
  dailyUsageMetrics_: UsageMetricsDailySnapshot_filter
  hourlyUsageMetrics_: UsageMetricsHourlySnapshot_filter
  financialMetrics_: FinancialsDailySnapshot_filter
  pools_: LiquidityPool_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DexAmmProtocol_filter]
  or: [DexAmmProtocol_filter]
}

enum DexAmmProtocol_orderBy {
  id
  name
  slug
  schemaVersion
  subgraphVersion
  methodologyVersion
  network
  type
  totalValueLockedUSD
  protocolControlledValueUSD
  cumulativeVolumeUSD
  cumulativeSupplySideRevenueUSD
  cumulativeProtocolSideRevenueUSD
  cumulativeTotalRevenueUSD
  cumulativeUniqueUsers
  totalPoolCount
  _regenesis
  dailyUsageMetrics
  hourlyUsageMetrics
  financialMetrics
  pools
}

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.

"""
interface Event {
  """ { Event type }-{ Transaction hash }-{ Log index } """
  id: ID!
  """ Transaction hash of the transaction that emitted this event """
  hash: String!
  """ Event log index. For transactions that don't emit event, create arbitrary index starting from 0 
  """
  logIndex: Int!
  """ The protocol this transaction belongs to """
  protocol: DexAmmProtocol!
  """ Address that received the tokens """
  to: String!
  """ Address that sent the tokens """
  from: String!
  """ Block number of this event """
  blockNumber: BigInt!
  """ Timestamp of this event """
  timestamp: BigInt!
}

input Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_gt: String
  hash_lt: String
  hash_gte: String
  hash_lte: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_contains_nocase: String
  hash_not_contains: String
  hash_not_contains_nocase: String
  hash_starts_with: String
  hash_starts_with_nocase: String
  hash_not_starts_with: String
  hash_not_starts_with_nocase: String
  hash_ends_with: String
  hash_ends_with_nocase: String
  hash_not_ends_with: String
  hash_not_ends_with_nocase: String
  logIndex: Int
  logIndex_not: Int
  logIndex_gt: Int
  logIndex_lt: Int
  logIndex_gte: Int
  logIndex_lte: Int
  logIndex_in: [Int!]
  logIndex_not_in: [Int!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Event_filter]
  or: [Event_filter]
}

enum Event_orderBy {
  id
  hash
  logIndex
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  to
  from
  blockNumber
  timestamp
}

type FinancialsDailySnapshot {
  """ ID is # of days since Unix epoch time """
  id: ID!
  """ Protocol this snapshot is associated with """
  protocol: DexAmmProtocol!
  """ Current TVL (Total Value Locked) of the entire protocol """
  totalValueLockedUSD: BigDecimal!
  """ Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. 
  """
  protocolControlledValueUSD: BigDecimal
  """ All trade volume occurred in a given day, in USD """
  dailyVolumeUSD: BigDecimal!
  """ All historical trade volume in USD """
  cumulativeVolumeUSD: BigDecimal!
  """ Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. 
  """
  dailySupplySideRevenueUSD: BigDecimal!
  """ Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. 
  """
  cumulativeSupplySideRevenueUSD: BigDecimal!
  """ Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. 
  """
  dailyProtocolSideRevenueUSD: BigDecimal!
  """ Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. 
  """
  cumulativeProtocolSideRevenueUSD: BigDecimal!
  """ All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. 
  """
  dailyTotalRevenueUSD: BigDecimal!
  """ All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. 
  """
  cumulativeTotalRevenueUSD: BigDecimal!
  """ Block number of this snapshot """
  blockNumber: BigInt!
  """ Timestamp of this snapshot """
  timestamp: BigInt!
}

input FinancialsDailySnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_not_in: [BigDecimal!]
  protocolControlledValueUSD: BigDecimal
  protocolControlledValueUSD_not: BigDecimal
  protocolControlledValueUSD_gt: BigDecimal
  protocolControlledValueUSD_lt: BigDecimal
  protocolControlledValueUSD_gte: BigDecimal
  protocolControlledValueUSD_lte: BigDecimal
  protocolControlledValueUSD_in: [BigDecimal!]
  protocolControlledValueUSD_not_in: [BigDecimal!]
  dailyVolumeUSD: BigDecimal
  dailyVolumeUSD_not: BigDecimal
  dailyVolumeUSD_gt: BigDecimal
  dailyVolumeUSD_lt: BigDecimal
  dailyVolumeUSD_gte: BigDecimal
  dailyVolumeUSD_lte: BigDecimal
  dailyVolumeUSD_in: [BigDecimal!]
  dailyVolumeUSD_not_in: [BigDecimal!]
  cumulativeVolumeUSD: BigDecimal
  cumulativeVolumeUSD_not: BigDecimal
  cumulativeVolumeUSD_gt: BigDecimal
  cumulativeVolumeUSD_lt: BigDecimal
  cumulativeVolumeUSD_gte: BigDecimal
  cumulativeVolumeUSD_lte: BigDecimal
  cumulativeVolumeUSD_in: [BigDecimal!]
  cumulativeVolumeUSD_not_in: [BigDecimal!]
  dailySupplySideRevenueUSD: BigDecimal
  dailySupplySideRevenueUSD_not: BigDecimal
  dailySupplySideRevenueUSD_gt: BigDecimal
  dailySupplySideRevenueUSD_lt: BigDecimal
  dailySupplySideRevenueUSD_gte: BigDecimal
  dailySupplySideRevenueUSD_lte: BigDecimal
  dailySupplySideRevenueUSD_in: [BigDecimal!]
  dailySupplySideRevenueUSD_not_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD: BigDecimal
  cumulativeSupplySideRevenueUSD_not: BigDecimal
  cumulativeSupplySideRevenueUSD_gt: BigDecimal
  cumulativeSupplySideRevenueUSD_lt: BigDecimal
  cumulativeSupplySideRevenueUSD_gte: BigDecimal
  cumulativeSupplySideRevenueUSD_lte: BigDecimal
  cumulativeSupplySideRevenueUSD_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD_not_in: [BigDecimal!]
  dailyProtocolSideRevenueUSD: BigDecimal
  dailyProtocolSideRevenueUSD_not: BigDecimal
  dailyProtocolSideRevenueUSD_gt: BigDecimal
  dailyProtocolSideRevenueUSD_lt: BigDecimal
  dailyProtocolSideRevenueUSD_gte: BigDecimal
  dailyProtocolSideRevenueUSD_lte: BigDecimal
  dailyProtocolSideRevenueUSD_in: [BigDecimal!]
  dailyProtocolSideRevenueUSD_not_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD: BigDecimal
  cumulativeProtocolSideRevenueUSD_not: BigDecimal
  cumulativeProtocolSideRevenueUSD_gt: BigDecimal
  cumulativeProtocolSideRevenueUSD_lt: BigDecimal
  cumulativeProtocolSideRevenueUSD_gte: BigDecimal
  cumulativeProtocolSideRevenueUSD_lte: BigDecimal
  cumulativeProtocolSideRevenueUSD_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD_not_in: [BigDecimal!]
  dailyTotalRevenueUSD: BigDecimal
  dailyTotalRevenueUSD_not: BigDecimal
  dailyTotalRevenueUSD_gt: BigDecimal
  dailyTotalRevenueUSD_lt: BigDecimal
  dailyTotalRevenueUSD_gte: BigDecimal
  dailyTotalRevenueUSD_lte: BigDecimal
  dailyTotalRevenueUSD_in: [BigDecimal!]
  dailyTotalRevenueUSD_not_in: [BigDecimal!]
  cumulativeTotalRevenueUSD: BigDecimal
  cumulativeTotalRevenueUSD_not: BigDecimal
  cumulativeTotalRevenueUSD_gt: BigDecimal
  cumulativeTotalRevenueUSD_lt: BigDecimal
  cumulativeTotalRevenueUSD_gte: BigDecimal
  cumulativeTotalRevenueUSD_lte: BigDecimal
  cumulativeTotalRevenueUSD_in: [BigDecimal!]
  cumulativeTotalRevenueUSD_not_in: [BigDecimal!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FinancialsDailySnapshot_filter]
  or: [FinancialsDailySnapshot_filter]
}

enum FinancialsDailySnapshot_orderBy {
  id
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  totalValueLockedUSD
  protocolControlledValueUSD
  dailyVolumeUSD
  cumulativeVolumeUSD
  dailySupplySideRevenueUSD
  cumulativeSupplySideRevenueUSD
  dailyProtocolSideRevenueUSD
  cumulativeProtocolSideRevenueUSD
  dailyTotalRevenueUSD
  cumulativeTotalRevenueUSD
  blockNumber
  timestamp
}

type LiquidityPool {
  """ Smart contract address of the pool """
  id: ID!
  """ The protocol this pool belongs to """
  protocol: DexAmmProtocol!
  """ Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT) """
  name: String
  """ Symbol of liquidity pool (e.g. 3CRV) """
  symbol: String
  """ Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer 
  """
  inputTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """ Token that is minted to track ownership of position in protocol """
  outputToken: Token
  """ Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon 
  """
  rewardTokens(skip: Int = 0, first: Int = 100, orderBy: RewardToken_orderBy, orderDirection: OrderDirection, where: RewardToken_filter): [RewardToken!]
  """ Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee. ) 
  """
  fees(skip: Int = 0, first: Int = 100, orderBy: LiquidityPoolFee_orderBy, orderDirection: OrderDirection, where: LiquidityPoolFee_filter): [LiquidityPoolFee!]!
  """ Whether this pool is single-sided (e.g. Bancor, Platypus's Alternative Pool). The specifics of the implementation depends on the protocol. 
  """
  isSingleSided: Boolean!
  """ Creation timestamp """
  createdTimestamp: BigInt!
  """ Creation block number """
  createdBlockNumber: BigInt!
  """ Current TVL (Total Value Locked) of this pool in USD """
  totalValueLockedUSD: BigDecimal!
  """ All revenue generated by the liquidity pool, accrued to the supply side. 
  """
  cumulativeSupplySideRevenueUSD: BigDecimal!
  """ All revenue generated by the liquidity pool, accrued to the protocol. 
  """
  cumulativeProtocolSideRevenueUSD: BigDecimal!
  """ All revenue generated by the liquidity pool. """
  cumulativeTotalRevenueUSD: BigDecimal!
  """ All historical trade volume occurred in this pool, in USD """
  cumulativeVolumeUSD: BigDecimal!
  """ Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. 
  """
  inputTokenBalances: [BigInt!]!
  """ Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool 
  """
  inputTokenWeights: [BigDecimal!]!
  """ Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) 
  """
  outputTokenSupply: BigInt
  """ Price per share of output token in USD """
  outputTokenPriceUSD: BigDecimal
  """ Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. 
  """
  stakedOutputTokenAmount: BigInt
  """ Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. 
  """
  rewardTokenEmissionsAmount: [BigInt!]
  """ Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. 
  """
  rewardTokenEmissionsUSD: [BigDecimal!]
  """ Liquidity pool daily snapshots """
  dailySnapshots(skip: Int = 0, first: Int = 100, orderBy: LiquidityPoolDailySnapshot_orderBy, orderDirection: OrderDirection, where: LiquidityPoolDailySnapshot_filter): [LiquidityPoolDailySnapshot!]!
  """ Liquidity pool hourly snapshots """
  hourlySnapshots(skip: Int = 0, first: Int = 100, orderBy: LiquidityPoolHourlySnapshot_orderBy, orderDirection: OrderDirection, where: LiquidityPoolHourlySnapshot_filter): [LiquidityPoolHourlySnapshot!]!
  """ All deposit (add liquidity) events occurred in this pool """
  deposits(skip: Int = 0, first: Int = 100, orderBy: Deposit_orderBy, orderDirection: OrderDirection, where: Deposit_filter): [Deposit!]!
  """ All withdraw (remove liquidity) events occurred in this pool """
  withdraws(skip: Int = 0, first: Int = 100, orderBy: Withdraw_orderBy, orderDirection: OrderDirection, where: Withdraw_filter): [Withdraw!]!
  """ All trade (swap) events occurred in this pool """
  swaps(skip: Int = 0, first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, where: Swap_filter): [Swap!]!
}

type LiquidityPoolDailySnapshot {
  """ { Smart contract address of the pool }-{ # of days since Unix epoch time } 
  """
  id: ID!
  """ The protocol this snapshot belongs to """
  protocol: DexAmmProtocol!
  """ The pool this snapshot belongs to """
  pool: LiquidityPool!
  """ Block number of this snapshot """
  blockNumber: BigInt!
  """ Timestamp of this snapshot """
  timestamp: BigInt!
  """ Current TVL (Total Value Locked) of this pool """
  totalValueLockedUSD: BigDecimal!
  """ All revenue generated by the liquidity pool, accrued to the supply side. 
  """
  cumulativeSupplySideRevenueUSD: BigDecimal!
  """ Daily revenue generated by the liquidity pool, accrued to the supply side. 
  """
  dailySupplySideRevenueUSD: BigDecimal!
  """ All revenue generated by the liquidity pool, accrued to the protocol. 
  """
  cumulativeProtocolSideRevenueUSD: BigDecimal!
  """ Daily revenue generated by the liquidity pool, accrued to the protocol. 
  """
  dailyProtocolSideRevenueUSD: BigDecimal!
  """ All revenue generated by the liquidity pool. """
  cumulativeTotalRevenueUSD: BigDecimal!
  """ Daily revenue generated by the liquidity pool. """
  dailyTotalRevenueUSD: BigDecimal!
  """ All trade volume occurred in a given day, in USD """
  dailyVolumeUSD: BigDecimal!
  """ All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool's `inputTokens` field. 
  """
  dailyVolumeByTokenAmount: [BigInt!]!
  """ All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool's `inputTokens` field. 
  """
  dailyVolumeByTokenUSD: [BigDecimal!]!
  """ All historical trade volume occurred in this pool, in USD """
  cumulativeVolumeUSD: BigDecimal!
  """ Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. 
  """
  inputTokenBalances: [BigInt!]!
  """ Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool 
  """
  inputTokenWeights: [BigDecimal!]!
  """ Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) 
  """
  outputTokenSupply: BigInt
  """ Price per share of output token in USD """
  outputTokenPriceUSD: BigDecimal
  """ Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. 
  """
  stakedOutputTokenAmount: BigInt
  """ Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. 
  """
  rewardTokenEmissionsAmount: [BigInt!]
  """ Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. 
  """
  rewardTokenEmissionsUSD: [BigDecimal!]
}

input LiquidityPoolDailySnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: LiquidityPool_filter
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_not_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD: BigDecimal
  cumulativeSupplySideRevenueUSD_not: BigDecimal
  cumulativeSupplySideRevenueUSD_gt: BigDecimal
  cumulativeSupplySideRevenueUSD_lt: BigDecimal
  cumulativeSupplySideRevenueUSD_gte: BigDecimal
  cumulativeSupplySideRevenueUSD_lte: BigDecimal
  cumulativeSupplySideRevenueUSD_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD_not_in: [BigDecimal!]
  dailySupplySideRevenueUSD: BigDecimal
  dailySupplySideRevenueUSD_not: BigDecimal
  dailySupplySideRevenueUSD_gt: BigDecimal
  dailySupplySideRevenueUSD_lt: BigDecimal
  dailySupplySideRevenueUSD_gte: BigDecimal
  dailySupplySideRevenueUSD_lte: BigDecimal
  dailySupplySideRevenueUSD_in: [BigDecimal!]
  dailySupplySideRevenueUSD_not_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD: BigDecimal
  cumulativeProtocolSideRevenueUSD_not: BigDecimal
  cumulativeProtocolSideRevenueUSD_gt: BigDecimal
  cumulativeProtocolSideRevenueUSD_lt: BigDecimal
  cumulativeProtocolSideRevenueUSD_gte: BigDecimal
  cumulativeProtocolSideRevenueUSD_lte: BigDecimal
  cumulativeProtocolSideRevenueUSD_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD_not_in: [BigDecimal!]
  dailyProtocolSideRevenueUSD: BigDecimal
  dailyProtocolSideRevenueUSD_not: BigDecimal
  dailyProtocolSideRevenueUSD_gt: BigDecimal
  dailyProtocolSideRevenueUSD_lt: BigDecimal
  dailyProtocolSideRevenueUSD_gte: BigDecimal
  dailyProtocolSideRevenueUSD_lte: BigDecimal
  dailyProtocolSideRevenueUSD_in: [BigDecimal!]
  dailyProtocolSideRevenueUSD_not_in: [BigDecimal!]
  cumulativeTotalRevenueUSD: BigDecimal
  cumulativeTotalRevenueUSD_not: BigDecimal
  cumulativeTotalRevenueUSD_gt: BigDecimal
  cumulativeTotalRevenueUSD_lt: BigDecimal
  cumulativeTotalRevenueUSD_gte: BigDecimal
  cumulativeTotalRevenueUSD_lte: BigDecimal
  cumulativeTotalRevenueUSD_in: [BigDecimal!]
  cumulativeTotalRevenueUSD_not_in: [BigDecimal!]
  dailyTotalRevenueUSD: BigDecimal
  dailyTotalRevenueUSD_not: BigDecimal
  dailyTotalRevenueUSD_gt: BigDecimal
  dailyTotalRevenueUSD_lt: BigDecimal
  dailyTotalRevenueUSD_gte: BigDecimal
  dailyTotalRevenueUSD_lte: BigDecimal
  dailyTotalRevenueUSD_in: [BigDecimal!]
  dailyTotalRevenueUSD_not_in: [BigDecimal!]
  dailyVolumeUSD: BigDecimal
  dailyVolumeUSD_not: BigDecimal
  dailyVolumeUSD_gt: BigDecimal
  dailyVolumeUSD_lt: BigDecimal
  dailyVolumeUSD_gte: BigDecimal
  dailyVolumeUSD_lte: BigDecimal
  dailyVolumeUSD_in: [BigDecimal!]
  dailyVolumeUSD_not_in: [BigDecimal!]
  dailyVolumeByTokenAmount: [BigInt!]
  dailyVolumeByTokenAmount_not: [BigInt!]
  dailyVolumeByTokenAmount_contains: [BigInt!]
  dailyVolumeByTokenAmount_contains_nocase: [BigInt!]
  dailyVolumeByTokenAmount_not_contains: [BigInt!]
  dailyVolumeByTokenAmount_not_contains_nocase: [BigInt!]
  dailyVolumeByTokenUSD: [BigDecimal!]
  dailyVolumeByTokenUSD_not: [BigDecimal!]
  dailyVolumeByTokenUSD_contains: [BigDecimal!]
  dailyVolumeByTokenUSD_contains_nocase: [BigDecimal!]
  dailyVolumeByTokenUSD_not_contains: [BigDecimal!]
  dailyVolumeByTokenUSD_not_contains_nocase: [BigDecimal!]
  cumulativeVolumeUSD: BigDecimal
  cumulativeVolumeUSD_not: BigDecimal
  cumulativeVolumeUSD_gt: BigDecimal
  cumulativeVolumeUSD_lt: BigDecimal
  cumulativeVolumeUSD_gte: BigDecimal
  cumulativeVolumeUSD_lte: BigDecimal
  cumulativeVolumeUSD_in: [BigDecimal!]
  cumulativeVolumeUSD_not_in: [BigDecimal!]
  inputTokenBalances: [BigInt!]
  inputTokenBalances_not: [BigInt!]
  inputTokenBalances_contains: [BigInt!]
  inputTokenBalances_contains_nocase: [BigInt!]
  inputTokenBalances_not_contains: [BigInt!]
  inputTokenBalances_not_contains_nocase: [BigInt!]
  inputTokenWeights: [BigDecimal!]
  inputTokenWeights_not: [BigDecimal!]
  inputTokenWeights_contains: [BigDecimal!]
  inputTokenWeights_contains_nocase: [BigDecimal!]
  inputTokenWeights_not_contains: [BigDecimal!]
  inputTokenWeights_not_contains_nocase: [BigDecimal!]
  outputTokenSupply: BigInt
  outputTokenSupply_not: BigInt
  outputTokenSupply_gt: BigInt
  outputTokenSupply_lt: BigInt
  outputTokenSupply_gte: BigInt
  outputTokenSupply_lte: BigInt
  outputTokenSupply_in: [BigInt!]
  outputTokenSupply_not_in: [BigInt!]
  outputTokenPriceUSD: BigDecimal
  outputTokenPriceUSD_not: BigDecimal
  outputTokenPriceUSD_gt: BigDecimal
  outputTokenPriceUSD_lt: BigDecimal
  outputTokenPriceUSD_gte: BigDecimal
  outputTokenPriceUSD_lte: BigDecimal
  outputTokenPriceUSD_in: [BigDecimal!]
  outputTokenPriceUSD_not_in: [BigDecimal!]
  stakedOutputTokenAmount: BigInt
  stakedOutputTokenAmount_not: BigInt
  stakedOutputTokenAmount_gt: BigInt
  stakedOutputTokenAmount_lt: BigInt
  stakedOutputTokenAmount_gte: BigInt
  stakedOutputTokenAmount_lte: BigInt
  stakedOutputTokenAmount_in: [BigInt!]
  stakedOutputTokenAmount_not_in: [BigInt!]
  rewardTokenEmissionsAmount: [BigInt!]
  rewardTokenEmissionsAmount_not: [BigInt!]
  rewardTokenEmissionsAmount_contains: [BigInt!]
  rewardTokenEmissionsAmount_contains_nocase: [BigInt!]
  rewardTokenEmissionsAmount_not_contains: [BigInt!]
  rewardTokenEmissionsAmount_not_contains_nocase: [BigInt!]
  rewardTokenEmissionsUSD: [BigDecimal!]
  rewardTokenEmissionsUSD_not: [BigDecimal!]
  rewardTokenEmissionsUSD_contains: [BigDecimal!]
  rewardTokenEmissionsUSD_contains_nocase: [BigDecimal!]
  rewardTokenEmissionsUSD_not_contains: [BigDecimal!]
  rewardTokenEmissionsUSD_not_contains_nocase: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPoolDailySnapshot_filter]
  or: [LiquidityPoolDailySnapshot_filter]
}

enum LiquidityPoolDailySnapshot_orderBy {
  id
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  pool
  pool__id
  pool__name
  pool__symbol
  pool__isSingleSided
  pool__createdTimestamp
  pool__createdBlockNumber
  pool__totalValueLockedUSD
  pool__cumulativeSupplySideRevenueUSD
  pool__cumulativeProtocolSideRevenueUSD
  pool__cumulativeTotalRevenueUSD
  pool__cumulativeVolumeUSD
  pool__outputTokenSupply
  pool__outputTokenPriceUSD
  pool__stakedOutputTokenAmount
  blockNumber
  timestamp
  totalValueLockedUSD
  cumulativeSupplySideRevenueUSD
  dailySupplySideRevenueUSD
  cumulativeProtocolSideRevenueUSD
  dailyProtocolSideRevenueUSD
  cumulativeTotalRevenueUSD
  dailyTotalRevenueUSD
  dailyVolumeUSD
  dailyVolumeByTokenAmount
  dailyVolumeByTokenUSD
  cumulativeVolumeUSD
  inputTokenBalances
  inputTokenWeights
  outputTokenSupply
  outputTokenPriceUSD
  stakedOutputTokenAmount
  rewardTokenEmissionsAmount
  rewardTokenEmissionsUSD
}

type LiquidityPoolFee {
  """ { Fee type }-{ Pool address } """
  id: ID!
  """ Fee as a percentage of the trade (swap) amount. Does not always apply 
  """
  feePercentage: BigDecimal!
  """ Type of fee this pool uses """
  feeType: LiquidityPoolFeeType!
}

enum LiquidityPoolFeeType {
  """ Total fixed fee paid by the user per trade, as a percentage of the traded amount. e.g. 0.3% for Uniswap v2, 0.3% for Sushiswap, 0.04% for Curve v1. 
  """
  FIXED_TRADING_FEE
  """ Some protocols use tiered fees instead of fixed fee (e.g. DYDX, DODO). Set `feePercentage` as 0 but handle the tiered fees in the mapping code. 
  """
  TIERED_TRADING_FEE
  """ Some protocols use dynamic fees instead of fixed fee (e.g. Balancer v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. 
  """
  DYNAMIC_TRADING_FEE
  """ Fixed fee that's paid to the LP, as a percentage of the traded amount. e.g. 0.25% for Sushiswap, 0.02% for Curve v1. 
  """
  FIXED_LP_FEE
  """ Some protocols use dynamic LP fees (e.g., Bancor v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. 
  """
  DYNAMIC_LP_FEE
  """ Fixed fee that's paid to the protocol, as a percentage of the traded amount. e.g. 0.05% for Sushiswap, 0.02% for Curve v1. 
  """
  FIXED_PROTOCOL_FEE
  """ Some protocols use dynamic protocol fees (e.g., Bancor v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. 
  """
  DYNAMIC_PROTOCOL_FEE
  """ One-time fee charged by the protocol during deposit, in percentages of the deposit token 
  """
  DEPOSIT_FEE
  """ One-time fee charged by the protocol (e.g. Bancor v3) during withdrawal, in percentages of the withdrawal token 
  """
  WITHDRAWAL_FEE
}

input LiquidityPoolFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  feePercentage: BigDecimal
  feePercentage_not: BigDecimal
  feePercentage_gt: BigDecimal
  feePercentage_lt: BigDecimal
  feePercentage_gte: BigDecimal
  feePercentage_lte: BigDecimal
  feePercentage_in: [BigDecimal!]
  feePercentage_not_in: [BigDecimal!]
  feeType: LiquidityPoolFeeType
  feeType_not: LiquidityPoolFeeType
  feeType_in: [LiquidityPoolFeeType!]
  feeType_not_in: [LiquidityPoolFeeType!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPoolFee_filter]
  or: [LiquidityPoolFee_filter]
}

enum LiquidityPoolFee_orderBy {
  id
  feePercentage
  feeType
}

type LiquidityPoolHourlySnapshot {
  """ { Smart contract address of the pool }-{ # of hours since Unix epoch time } 
  """
  id: ID!
  """ The protocol this snapshot belongs to """
  protocol: DexAmmProtocol!
  """ The pool this snapshot belongs to """
  pool: LiquidityPool!
  """ Block number of this snapshot """
  blockNumber: BigInt!
  """ Timestamp of this snapshot """
  timestamp: BigInt!
  """ Current TVL (Total Value Locked) of this pool """
  totalValueLockedUSD: BigDecimal!
  """ All revenue generated by the liquidity pool, accrued to the supply side. 
  """
  cumulativeSupplySideRevenueUSD: BigDecimal!
  """ Hourly revenue generated by the liquidity pool, accrued to the supply side. 
  """
  hourlySupplySideRevenueUSD: BigDecimal!
  """ All revenue generated by the liquidity pool, accrued to the protocol. 
  """
  cumulativeProtocolSideRevenueUSD: BigDecimal!
  """ Hourly revenue generated by the liquidity pool, accrued to the protocol. 
  """
  hourlyProtocolSideRevenueUSD: BigDecimal!
  """ All revenue generated by the liquidity pool. """
  cumulativeTotalRevenueUSD: BigDecimal!
  """ Hourly revenue generated by the liquidity pool. """
  hourlyTotalRevenueUSD: BigDecimal!
  """ All trade volume occurred in a given hour, in USD """
  hourlyVolumeUSD: BigDecimal!
  """ All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool's `inputTokens` field. 
  """
  hourlyVolumeByTokenAmount: [BigInt!]!
  """ All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool's `inputTokens` field. 
  """
  hourlyVolumeByTokenUSD: [BigDecimal!]!
  """ All historical trade volume occurred in this pool, in USD """
  cumulativeVolumeUSD: BigDecimal!
  """ Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. 
  """
  inputTokenBalances: [BigInt!]!
  """ Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool 
  """
  inputTokenWeights: [BigDecimal!]!
  """ Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) 
  """
  outputTokenSupply: BigInt
  """ Price per share of output token in USD """
  outputTokenPriceUSD: BigDecimal
  """ Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. 
  """
  stakedOutputTokenAmount: BigInt
  """ Per-block reward token emission as of the current block normalized to a day (not hour), in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. 
  """
  rewardTokenEmissionsAmount: [BigInt!]
  """ Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. 
  """
  rewardTokenEmissionsUSD: [BigDecimal!]
}

input LiquidityPoolHourlySnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: LiquidityPool_filter
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_not_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD: BigDecimal
  cumulativeSupplySideRevenueUSD_not: BigDecimal
  cumulativeSupplySideRevenueUSD_gt: BigDecimal
  cumulativeSupplySideRevenueUSD_lt: BigDecimal
  cumulativeSupplySideRevenueUSD_gte: BigDecimal
  cumulativeSupplySideRevenueUSD_lte: BigDecimal
  cumulativeSupplySideRevenueUSD_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD_not_in: [BigDecimal!]
  hourlySupplySideRevenueUSD: BigDecimal
  hourlySupplySideRevenueUSD_not: BigDecimal
  hourlySupplySideRevenueUSD_gt: BigDecimal
  hourlySupplySideRevenueUSD_lt: BigDecimal
  hourlySupplySideRevenueUSD_gte: BigDecimal
  hourlySupplySideRevenueUSD_lte: BigDecimal
  hourlySupplySideRevenueUSD_in: [BigDecimal!]
  hourlySupplySideRevenueUSD_not_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD: BigDecimal
  cumulativeProtocolSideRevenueUSD_not: BigDecimal
  cumulativeProtocolSideRevenueUSD_gt: BigDecimal
  cumulativeProtocolSideRevenueUSD_lt: BigDecimal
  cumulativeProtocolSideRevenueUSD_gte: BigDecimal
  cumulativeProtocolSideRevenueUSD_lte: BigDecimal
  cumulativeProtocolSideRevenueUSD_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD_not_in: [BigDecimal!]
  hourlyProtocolSideRevenueUSD: BigDecimal
  hourlyProtocolSideRevenueUSD_not: BigDecimal
  hourlyProtocolSideRevenueUSD_gt: BigDecimal
  hourlyProtocolSideRevenueUSD_lt: BigDecimal
  hourlyProtocolSideRevenueUSD_gte: BigDecimal
  hourlyProtocolSideRevenueUSD_lte: BigDecimal
  hourlyProtocolSideRevenueUSD_in: [BigDecimal!]
  hourlyProtocolSideRevenueUSD_not_in: [BigDecimal!]
  cumulativeTotalRevenueUSD: BigDecimal
  cumulativeTotalRevenueUSD_not: BigDecimal
  cumulativeTotalRevenueUSD_gt: BigDecimal
  cumulativeTotalRevenueUSD_lt: BigDecimal
  cumulativeTotalRevenueUSD_gte: BigDecimal
  cumulativeTotalRevenueUSD_lte: BigDecimal
  cumulativeTotalRevenueUSD_in: [BigDecimal!]
  cumulativeTotalRevenueUSD_not_in: [BigDecimal!]
  hourlyTotalRevenueUSD: BigDecimal
  hourlyTotalRevenueUSD_not: BigDecimal
  hourlyTotalRevenueUSD_gt: BigDecimal
  hourlyTotalRevenueUSD_lt: BigDecimal
  hourlyTotalRevenueUSD_gte: BigDecimal
  hourlyTotalRevenueUSD_lte: BigDecimal
  hourlyTotalRevenueUSD_in: [BigDecimal!]
  hourlyTotalRevenueUSD_not_in: [BigDecimal!]
  hourlyVolumeUSD: BigDecimal
  hourlyVolumeUSD_not: BigDecimal
  hourlyVolumeUSD_gt: BigDecimal
  hourlyVolumeUSD_lt: BigDecimal
  hourlyVolumeUSD_gte: BigDecimal
  hourlyVolumeUSD_lte: BigDecimal
  hourlyVolumeUSD_in: [BigDecimal!]
  hourlyVolumeUSD_not_in: [BigDecimal!]
  hourlyVolumeByTokenAmount: [BigInt!]
  hourlyVolumeByTokenAmount_not: [BigInt!]
  hourlyVolumeByTokenAmount_contains: [BigInt!]
  hourlyVolumeByTokenAmount_contains_nocase: [BigInt!]
  hourlyVolumeByTokenAmount_not_contains: [BigInt!]
  hourlyVolumeByTokenAmount_not_contains_nocase: [BigInt!]
  hourlyVolumeByTokenUSD: [BigDecimal!]
  hourlyVolumeByTokenUSD_not: [BigDecimal!]
  hourlyVolumeByTokenUSD_contains: [BigDecimal!]
  hourlyVolumeByTokenUSD_contains_nocase: [BigDecimal!]
  hourlyVolumeByTokenUSD_not_contains: [BigDecimal!]
  hourlyVolumeByTokenUSD_not_contains_nocase: [BigDecimal!]
  cumulativeVolumeUSD: BigDecimal
  cumulativeVolumeUSD_not: BigDecimal
  cumulativeVolumeUSD_gt: BigDecimal
  cumulativeVolumeUSD_lt: BigDecimal
  cumulativeVolumeUSD_gte: BigDecimal
  cumulativeVolumeUSD_lte: BigDecimal
  cumulativeVolumeUSD_in: [BigDecimal!]
  cumulativeVolumeUSD_not_in: [BigDecimal!]
  inputTokenBalances: [BigInt!]
  inputTokenBalances_not: [BigInt!]
  inputTokenBalances_contains: [BigInt!]
  inputTokenBalances_contains_nocase: [BigInt!]
  inputTokenBalances_not_contains: [BigInt!]
  inputTokenBalances_not_contains_nocase: [BigInt!]
  inputTokenWeights: [BigDecimal!]
  inputTokenWeights_not: [BigDecimal!]
  inputTokenWeights_contains: [BigDecimal!]
  inputTokenWeights_contains_nocase: [BigDecimal!]
  inputTokenWeights_not_contains: [BigDecimal!]
  inputTokenWeights_not_contains_nocase: [BigDecimal!]
  outputTokenSupply: BigInt
  outputTokenSupply_not: BigInt
  outputTokenSupply_gt: BigInt
  outputTokenSupply_lt: BigInt
  outputTokenSupply_gte: BigInt
  outputTokenSupply_lte: BigInt
  outputTokenSupply_in: [BigInt!]
  outputTokenSupply_not_in: [BigInt!]
  outputTokenPriceUSD: BigDecimal
  outputTokenPriceUSD_not: BigDecimal
  outputTokenPriceUSD_gt: BigDecimal
  outputTokenPriceUSD_lt: BigDecimal
  outputTokenPriceUSD_gte: BigDecimal
  outputTokenPriceUSD_lte: BigDecimal
  outputTokenPriceUSD_in: [BigDecimal!]
  outputTokenPriceUSD_not_in: [BigDecimal!]
  stakedOutputTokenAmount: BigInt
  stakedOutputTokenAmount_not: BigInt
  stakedOutputTokenAmount_gt: BigInt
  stakedOutputTokenAmount_lt: BigInt
  stakedOutputTokenAmount_gte: BigInt
  stakedOutputTokenAmount_lte: BigInt
  stakedOutputTokenAmount_in: [BigInt!]
  stakedOutputTokenAmount_not_in: [BigInt!]
  rewardTokenEmissionsAmount: [BigInt!]
  rewardTokenEmissionsAmount_not: [BigInt!]
  rewardTokenEmissionsAmount_contains: [BigInt!]
  rewardTokenEmissionsAmount_contains_nocase: [BigInt!]
  rewardTokenEmissionsAmount_not_contains: [BigInt!]
  rewardTokenEmissionsAmount_not_contains_nocase: [BigInt!]
  rewardTokenEmissionsUSD: [BigDecimal!]
  rewardTokenEmissionsUSD_not: [BigDecimal!]
  rewardTokenEmissionsUSD_contains: [BigDecimal!]
  rewardTokenEmissionsUSD_contains_nocase: [BigDecimal!]
  rewardTokenEmissionsUSD_not_contains: [BigDecimal!]
  rewardTokenEmissionsUSD_not_contains_nocase: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPoolHourlySnapshot_filter]
  or: [LiquidityPoolHourlySnapshot_filter]
}

enum LiquidityPoolHourlySnapshot_orderBy {
  id
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  pool
  pool__id
  pool__name
  pool__symbol
  pool__isSingleSided
  pool__createdTimestamp
  pool__createdBlockNumber
  pool__totalValueLockedUSD
  pool__cumulativeSupplySideRevenueUSD
  pool__cumulativeProtocolSideRevenueUSD
  pool__cumulativeTotalRevenueUSD
  pool__cumulativeVolumeUSD
  pool__outputTokenSupply
  pool__outputTokenPriceUSD
  pool__stakedOutputTokenAmount
  blockNumber
  timestamp
  totalValueLockedUSD
  cumulativeSupplySideRevenueUSD
  hourlySupplySideRevenueUSD
  cumulativeProtocolSideRevenueUSD
  hourlyProtocolSideRevenueUSD
  cumulativeTotalRevenueUSD
  hourlyTotalRevenueUSD
  hourlyVolumeUSD
  hourlyVolumeByTokenAmount
  hourlyVolumeByTokenUSD
  cumulativeVolumeUSD
  inputTokenBalances
  inputTokenWeights
  outputTokenSupply
  outputTokenPriceUSD
  stakedOutputTokenAmount
  rewardTokenEmissionsAmount
  rewardTokenEmissionsUSD
}

input LiquidityPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  inputTokens: [String!]
  inputTokens_not: [String!]
  inputTokens_contains: [String!]
  inputTokens_contains_nocase: [String!]
  inputTokens_not_contains: [String!]
  inputTokens_not_contains_nocase: [String!]
  inputTokens_: Token_filter
  outputToken: String
  outputToken_not: String
  outputToken_gt: String
  outputToken_lt: String
  outputToken_gte: String
  outputToken_lte: String
  outputToken_in: [String!]
  outputToken_not_in: [String!]
  outputToken_contains: String
  outputToken_contains_nocase: String
  outputToken_not_contains: String
  outputToken_not_contains_nocase: String
  outputToken_starts_with: String
  outputToken_starts_with_nocase: String
  outputToken_not_starts_with: String
  outputToken_not_starts_with_nocase: String
  outputToken_ends_with: String
  outputToken_ends_with_nocase: String
  outputToken_not_ends_with: String
  outputToken_not_ends_with_nocase: String
  outputToken_: Token_filter
  rewardTokens: [String!]
  rewardTokens_not: [String!]
  rewardTokens_contains: [String!]
  rewardTokens_contains_nocase: [String!]
  rewardTokens_not_contains: [String!]
  rewardTokens_not_contains_nocase: [String!]
  rewardTokens_: RewardToken_filter
  fees: [String!]
  fees_not: [String!]
  fees_contains: [String!]
  fees_contains_nocase: [String!]
  fees_not_contains: [String!]
  fees_not_contains_nocase: [String!]
  fees_: LiquidityPoolFee_filter
  isSingleSided: Boolean
  isSingleSided_not: Boolean
  isSingleSided_in: [Boolean!]
  isSingleSided_not_in: [Boolean!]
  createdTimestamp: BigInt
  createdTimestamp_not: BigInt
  createdTimestamp_gt: BigInt
  createdTimestamp_lt: BigInt
  createdTimestamp_gte: BigInt
  createdTimestamp_lte: BigInt
  createdTimestamp_in: [BigInt!]
  createdTimestamp_not_in: [BigInt!]
  createdBlockNumber: BigInt
  createdBlockNumber_not: BigInt
  createdBlockNumber_gt: BigInt
  createdBlockNumber_lt: BigInt
  createdBlockNumber_gte: BigInt
  createdBlockNumber_lte: BigInt
  createdBlockNumber_in: [BigInt!]
  createdBlockNumber_not_in: [BigInt!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_not_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD: BigDecimal
  cumulativeSupplySideRevenueUSD_not: BigDecimal
  cumulativeSupplySideRevenueUSD_gt: BigDecimal
  cumulativeSupplySideRevenueUSD_lt: BigDecimal
  cumulativeSupplySideRevenueUSD_gte: BigDecimal
  cumulativeSupplySideRevenueUSD_lte: BigDecimal
  cumulativeSupplySideRevenueUSD_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD_not_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD: BigDecimal
  cumulativeProtocolSideRevenueUSD_not: BigDecimal
  cumulativeProtocolSideRevenueUSD_gt: BigDecimal
  cumulativeProtocolSideRevenueUSD_lt: BigDecimal
  cumulativeProtocolSideRevenueUSD_gte: BigDecimal
  cumulativeProtocolSideRevenueUSD_lte: BigDecimal
  cumulativeProtocolSideRevenueUSD_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD_not_in: [BigDecimal!]
  cumulativeTotalRevenueUSD: BigDecimal
  cumulativeTotalRevenueUSD_not: BigDecimal
  cumulativeTotalRevenueUSD_gt: BigDecimal
  cumulativeTotalRevenueUSD_lt: BigDecimal
  cumulativeTotalRevenueUSD_gte: BigDecimal
  cumulativeTotalRevenueUSD_lte: BigDecimal
  cumulativeTotalRevenueUSD_in: [BigDecimal!]
  cumulativeTotalRevenueUSD_not_in: [BigDecimal!]
  cumulativeVolumeUSD: BigDecimal
  cumulativeVolumeUSD_not: BigDecimal
  cumulativeVolumeUSD_gt: BigDecimal
  cumulativeVolumeUSD_lt: BigDecimal
  cumulativeVolumeUSD_gte: BigDecimal
  cumulativeVolumeUSD_lte: BigDecimal
  cumulativeVolumeUSD_in: [BigDecimal!]
  cumulativeVolumeUSD_not_in: [BigDecimal!]
  inputTokenBalances: [BigInt!]
  inputTokenBalances_not: [BigInt!]
  inputTokenBalances_contains: [BigInt!]
  inputTokenBalances_contains_nocase: [BigInt!]
  inputTokenBalances_not_contains: [BigInt!]
  inputTokenBalances_not_contains_nocase: [BigInt!]
  inputTokenWeights: [BigDecimal!]
  inputTokenWeights_not: [BigDecimal!]
  inputTokenWeights_contains: [BigDecimal!]
  inputTokenWeights_contains_nocase: [BigDecimal!]
  inputTokenWeights_not_contains: [BigDecimal!]
  inputTokenWeights_not_contains_nocase: [BigDecimal!]
  outputTokenSupply: BigInt
  outputTokenSupply_not: BigInt
  outputTokenSupply_gt: BigInt
  outputTokenSupply_lt: BigInt
  outputTokenSupply_gte: BigInt
  outputTokenSupply_lte: BigInt
  outputTokenSupply_in: [BigInt!]
  outputTokenSupply_not_in: [BigInt!]
  outputTokenPriceUSD: BigDecimal
  outputTokenPriceUSD_not: BigDecimal
  outputTokenPriceUSD_gt: BigDecimal
  outputTokenPriceUSD_lt: BigDecimal
  outputTokenPriceUSD_gte: BigDecimal
  outputTokenPriceUSD_lte: BigDecimal
  outputTokenPriceUSD_in: [BigDecimal!]
  outputTokenPriceUSD_not_in: [BigDecimal!]
  stakedOutputTokenAmount: BigInt
  stakedOutputTokenAmount_not: BigInt
  stakedOutputTokenAmount_gt: BigInt
  stakedOutputTokenAmount_lt: BigInt
  stakedOutputTokenAmount_gte: BigInt
  stakedOutputTokenAmount_lte: BigInt
  stakedOutputTokenAmount_in: [BigInt!]
  stakedOutputTokenAmount_not_in: [BigInt!]
  rewardTokenEmissionsAmount: [BigInt!]
  rewardTokenEmissionsAmount_not: [BigInt!]
  rewardTokenEmissionsAmount_contains: [BigInt!]
  rewardTokenEmissionsAmount_contains_nocase: [BigInt!]
  rewardTokenEmissionsAmount_not_contains: [BigInt!]
  rewardTokenEmissionsAmount_not_contains_nocase: [BigInt!]
  rewardTokenEmissionsUSD: [BigDecimal!]
  rewardTokenEmissionsUSD_not: [BigDecimal!]
  rewardTokenEmissionsUSD_contains: [BigDecimal!]
  rewardTokenEmissionsUSD_contains_nocase: [BigDecimal!]
  rewardTokenEmissionsUSD_not_contains: [BigDecimal!]
  rewardTokenEmissionsUSD_not_contains_nocase: [BigDecimal!]
  dailySnapshots_: LiquidityPoolDailySnapshot_filter
  hourlySnapshots_: LiquidityPoolHourlySnapshot_filter
  deposits_: Deposit_filter
  withdraws_: Withdraw_filter
  swaps_: Swap_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPool_filter]
  or: [LiquidityPool_filter]
}

enum LiquidityPool_orderBy {
  id
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  name
  symbol
  inputTokens
  outputToken
  outputToken__id
  outputToken__name
  outputToken__symbol
  outputToken__decimals
  outputToken__lastPriceUSD
  outputToken__lastPriceBlockNumber
  rewardTokens
  fees
  isSingleSided
  createdTimestamp
  createdBlockNumber
  totalValueLockedUSD
  cumulativeSupplySideRevenueUSD
  cumulativeProtocolSideRevenueUSD
  cumulativeTotalRevenueUSD
  cumulativeVolumeUSD
  inputTokenBalances
  inputTokenWeights
  outputTokenSupply
  outputTokenPriceUSD
  stakedOutputTokenAmount
  rewardTokenEmissionsAmount
  rewardTokenEmissionsUSD
  dailySnapshots
  hourlySnapshots
  deposits
  withdraws
  swaps
}

enum Network {
  ARBITRUM_ONE
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC
  CELO
  COSMOS
  CRONOS
  MAINNET
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC
  XDAI
}

interface Protocol {
  """ Smart contract address of the protocol's main contract (Factory, Registry, etc) 
  """
  id: ID!
  """ Name of the protocol, including version. e.g. Uniswap v3 """
  name: String!
  """ Slug of protocol, including version. e.g. uniswap-v3 """
  slug: String!
  """ Version of the subgraph schema, in SemVer format (e.g. 1.0.0) """
  schemaVersion: String!
  """ Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) 
  """
  subgraphVersion: String!
  """ Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) 
  """
  methodologyVersion: String!
  """ The blockchain network this subgraph is indexing on """
  network: Network!
  """ The type of protocol (e.g. DEX, Lending, Yield, etc) """
  type: ProtocolType!
  """ Current TVL (Total Value Locked) of the entire protocol """
  totalValueLockedUSD: BigDecimal!
  """ Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. 
  """
  protocolControlledValueUSD: BigDecimal
  """ Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. 
  """
  cumulativeSupplySideRevenueUSD: BigDecimal!
  """ Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. 
  """
  cumulativeProtocolSideRevenueUSD: BigDecimal!
  """ All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. 
  """
  cumulativeTotalRevenueUSD: BigDecimal!
  """ Number of cumulative unique users """
  cumulativeUniqueUsers: Int!
  """ Total number of pools """
  totalPoolCount: Int!
  """ Daily usage metrics for this protocol """
  dailyUsageMetrics(skip: Int = 0, first: Int = 100, orderBy: UsageMetricsDailySnapshot_orderBy, orderDirection: OrderDirection, where: UsageMetricsDailySnapshot_filter): [UsageMetricsDailySnapshot!]!
  """ Hourly usage metrics for this protocol """
  hourlyUsageMetrics(skip: Int = 0, first: Int = 100, orderBy: UsageMetricsHourlySnapshot_orderBy, orderDirection: OrderDirection, where: UsageMetricsHourlySnapshot_filter): [UsageMetricsHourlySnapshot!]!
  """ Daily financial metrics for this protocol """
  financialMetrics(skip: Int = 0, first: Int = 100, orderBy: FinancialsDailySnapshot_orderBy, orderDirection: OrderDirection, where: FinancialsDailySnapshot_filter): [FinancialsDailySnapshot!]!
}

enum ProtocolType {
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  GENERIC
}

input Protocol_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  slug: String
  slug_not: String
  slug_gt: String
  slug_lt: String
  slug_gte: String
  slug_lte: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_contains: String
  slug_contains_nocase: String
  slug_not_contains: String
  slug_not_contains_nocase: String
  slug_starts_with: String
  slug_starts_with_nocase: String
  slug_not_starts_with: String
  slug_not_starts_with_nocase: String
  slug_ends_with: String
  slug_ends_with_nocase: String
  slug_not_ends_with: String
  slug_not_ends_with_nocase: String
  schemaVersion: String
  schemaVersion_not: String
  schemaVersion_gt: String
  schemaVersion_lt: String
  schemaVersion_gte: String
  schemaVersion_lte: String
  schemaVersion_in: [String!]
  schemaVersion_not_in: [String!]
  schemaVersion_contains: String
  schemaVersion_contains_nocase: String
  schemaVersion_not_contains: String
  schemaVersion_not_contains_nocase: String
  schemaVersion_starts_with: String
  schemaVersion_starts_with_nocase: String
  schemaVersion_not_starts_with: String
  schemaVersion_not_starts_with_nocase: String
  schemaVersion_ends_with: String
  schemaVersion_ends_with_nocase: String
  schemaVersion_not_ends_with: String
  schemaVersion_not_ends_with_nocase: String
  subgraphVersion: String
  subgraphVersion_not: String
  subgraphVersion_gt: String
  subgraphVersion_lt: String
  subgraphVersion_gte: String
  subgraphVersion_lte: String
  subgraphVersion_in: [String!]
  subgraphVersion_not_in: [String!]
  subgraphVersion_contains: String
  subgraphVersion_contains_nocase: String
  subgraphVersion_not_contains: String
  subgraphVersion_not_contains_nocase: String
  subgraphVersion_starts_with: String
  subgraphVersion_starts_with_nocase: String
  subgraphVersion_not_starts_with: String
  subgraphVersion_not_starts_with_nocase: String
  subgraphVersion_ends_with: String
  subgraphVersion_ends_with_nocase: String
  subgraphVersion_not_ends_with: String
  subgraphVersion_not_ends_with_nocase: String
  methodologyVersion: String
  methodologyVersion_not: String
  methodologyVersion_gt: String
  methodologyVersion_lt: String
  methodologyVersion_gte: String
  methodologyVersion_lte: String
  methodologyVersion_in: [String!]
  methodologyVersion_not_in: [String!]
  methodologyVersion_contains: String
  methodologyVersion_contains_nocase: String
  methodologyVersion_not_contains: String
  methodologyVersion_not_contains_nocase: String
  methodologyVersion_starts_with: String
  methodologyVersion_starts_with_nocase: String
  methodologyVersion_not_starts_with: String
  methodologyVersion_not_starts_with_nocase: String
  methodologyVersion_ends_with: String
  methodologyVersion_ends_with_nocase: String
  methodologyVersion_not_ends_with: String
  methodologyVersion_not_ends_with_nocase: String
  network: Network
  network_not: Network
  network_in: [Network!]
  network_not_in: [Network!]
  type: ProtocolType
  type_not: ProtocolType
  type_in: [ProtocolType!]
  type_not_in: [ProtocolType!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_not_in: [BigDecimal!]
  protocolControlledValueUSD: BigDecimal
  protocolControlledValueUSD_not: BigDecimal
  protocolControlledValueUSD_gt: BigDecimal
  protocolControlledValueUSD_lt: BigDecimal
  protocolControlledValueUSD_gte: BigDecimal
  protocolControlledValueUSD_lte: BigDecimal
  protocolControlledValueUSD_in: [BigDecimal!]
  protocolControlledValueUSD_not_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD: BigDecimal
  cumulativeSupplySideRevenueUSD_not: BigDecimal
  cumulativeSupplySideRevenueUSD_gt: BigDecimal
  cumulativeSupplySideRevenueUSD_lt: BigDecimal
  cumulativeSupplySideRevenueUSD_gte: BigDecimal
  cumulativeSupplySideRevenueUSD_lte: BigDecimal
  cumulativeSupplySideRevenueUSD_in: [BigDecimal!]
  cumulativeSupplySideRevenueUSD_not_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD: BigDecimal
  cumulativeProtocolSideRevenueUSD_not: BigDecimal
  cumulativeProtocolSideRevenueUSD_gt: BigDecimal
  cumulativeProtocolSideRevenueUSD_lt: BigDecimal
  cumulativeProtocolSideRevenueUSD_gte: BigDecimal
  cumulativeProtocolSideRevenueUSD_lte: BigDecimal
  cumulativeProtocolSideRevenueUSD_in: [BigDecimal!]
  cumulativeProtocolSideRevenueUSD_not_in: [BigDecimal!]
  cumulativeTotalRevenueUSD: BigDecimal
  cumulativeTotalRevenueUSD_not: BigDecimal
  cumulativeTotalRevenueUSD_gt: BigDecimal
  cumulativeTotalRevenueUSD_lt: BigDecimal
  cumulativeTotalRevenueUSD_gte: BigDecimal
  cumulativeTotalRevenueUSD_lte: BigDecimal
  cumulativeTotalRevenueUSD_in: [BigDecimal!]
  cumulativeTotalRevenueUSD_not_in: [BigDecimal!]
  cumulativeUniqueUsers: Int
  cumulativeUniqueUsers_not: Int
  cumulativeUniqueUsers_gt: Int
  cumulativeUniqueUsers_lt: Int
  cumulativeUniqueUsers_gte: Int
  cumulativeUniqueUsers_lte: Int
  cumulativeUniqueUsers_in: [Int!]
  cumulativeUniqueUsers_not_in: [Int!]
  totalPoolCount: Int
  totalPoolCount_not: Int
  totalPoolCount_gt: Int
  totalPoolCount_lt: Int
  totalPoolCount_gte: Int
  totalPoolCount_lte: Int
  totalPoolCount_in: [Int!]
  totalPoolCount_not_in: [Int!]
  dailyUsageMetrics_: UsageMetricsDailySnapshot_filter
  hourlyUsageMetrics_: UsageMetricsHourlySnapshot_filter
  financialMetrics_: FinancialsDailySnapshot_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Protocol_filter]
  or: [Protocol_filter]
}

enum Protocol_orderBy {
  id
  name
  slug
  schemaVersion
  subgraphVersion
  methodologyVersion
  network
  type
  totalValueLockedUSD
  protocolControlledValueUSD
  cumulativeSupplySideRevenueUSD
  cumulativeProtocolSideRevenueUSD
  cumulativeTotalRevenueUSD
  cumulativeUniqueUsers
  totalPoolCount
  dailyUsageMetrics
  hourlyUsageMetrics
  financialMetrics
}

type RewardToken {
  """ { Reward token type }-{ Smart contract address of the reward token } """
  id: ID!
  """ Reference to the actual token """
  token: Token!
  """ The type of the reward token """
  type: RewardTokenType!
}

enum RewardTokenType {
  """ For reward tokens awarded to LPs/lenders """
  DEPOSIT
  """ For reward tokens awarded to borrowers """
  BORROW
}

input RewardToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  type: RewardTokenType
  type_not: RewardTokenType
  type_in: [RewardTokenType!]
  type_not_in: [RewardTokenType!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RewardToken_filter]
  or: [RewardToken_filter]
}

enum RewardToken_orderBy {
  id
  token
  token__id
  token__name
  token__symbol
  token__decimals
  token__lastPriceUSD
  token__lastPriceBlockNumber
  type
}

type Swap implements Event {
  """ swap-{ Transaction hash }-{ Log index } """
  id: ID!
  """ Transaction hash of the transaction that emitted this event """
  hash: String!
  """ Event log index. For transactions that don't emit event, create arbitrary index starting from 0 
  """
  logIndex: Int!
  """ The protocol this transaction belongs to """
  protocol: DexAmmProtocol!
  """ Address that received the tokens """
  to: String!
  """ Address that sent the tokens """
  from: String!
  """ Block number of this event """
  blockNumber: BigInt!
  """ Timestamp of this event """
  timestamp: BigInt!
  """ Token deposited into pool """
  tokenIn: Token!
  """ Amount of token deposited into pool in native units """
  amountIn: BigInt!
  """ Amount of token deposited into pool in USD """
  amountInUSD: BigDecimal!
  """ Token withdrawn from pool """
  tokenOut: Token!
  """ Amount of token withdrawn from pool in native units """
  amountOut: BigInt!
  """ Amount of token withdrawn from pool in USD """
  amountOutUSD: BigDecimal!
  """ The pool involving this transaction """
  pool: LiquidityPool!
}

input Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_gt: String
  hash_lt: String
  hash_gte: String
  hash_lte: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_contains_nocase: String
  hash_not_contains: String
  hash_not_contains_nocase: String
  hash_starts_with: String
  hash_starts_with_nocase: String
  hash_not_starts_with: String
  hash_not_starts_with_nocase: String
  hash_ends_with: String
  hash_ends_with_nocase: String
  hash_not_ends_with: String
  hash_not_ends_with_nocase: String
  logIndex: Int
  logIndex_not: Int
  logIndex_gt: Int
  logIndex_lt: Int
  logIndex_gte: Int
  logIndex_lte: Int
  logIndex_in: [Int!]
  logIndex_not_in: [Int!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  tokenIn: String
  tokenIn_not: String
  tokenIn_gt: String
  tokenIn_lt: String
  tokenIn_gte: String
  tokenIn_lte: String
  tokenIn_in: [String!]
  tokenIn_not_in: [String!]
  tokenIn_contains: String
  tokenIn_contains_nocase: String
  tokenIn_not_contains: String
  tokenIn_not_contains_nocase: String
  tokenIn_starts_with: String
  tokenIn_starts_with_nocase: String
  tokenIn_not_starts_with: String
  tokenIn_not_starts_with_nocase: String
  tokenIn_ends_with: String
  tokenIn_ends_with_nocase: String
  tokenIn_not_ends_with: String
  tokenIn_not_ends_with_nocase: String
  tokenIn_: Token_filter
  amountIn: BigInt
  amountIn_not: BigInt
  amountIn_gt: BigInt
  amountIn_lt: BigInt
  amountIn_gte: BigInt
  amountIn_lte: BigInt
  amountIn_in: [BigInt!]
  amountIn_not_in: [BigInt!]
  amountInUSD: BigDecimal
  amountInUSD_not: BigDecimal
  amountInUSD_gt: BigDecimal
  amountInUSD_lt: BigDecimal
  amountInUSD_gte: BigDecimal
  amountInUSD_lte: BigDecimal
  amountInUSD_in: [BigDecimal!]
  amountInUSD_not_in: [BigDecimal!]
  tokenOut: String
  tokenOut_not: String
  tokenOut_gt: String
  tokenOut_lt: String
  tokenOut_gte: String
  tokenOut_lte: String
  tokenOut_in: [String!]
  tokenOut_not_in: [String!]
  tokenOut_contains: String
  tokenOut_contains_nocase: String
  tokenOut_not_contains: String
  tokenOut_not_contains_nocase: String
  tokenOut_starts_with: String
  tokenOut_starts_with_nocase: String
  tokenOut_not_starts_with: String
  tokenOut_not_starts_with_nocase: String
  tokenOut_ends_with: String
  tokenOut_ends_with_nocase: String
  tokenOut_not_ends_with: String
  tokenOut_not_ends_with_nocase: String
  tokenOut_: Token_filter
  amountOut: BigInt
  amountOut_not: BigInt
  amountOut_gt: BigInt
  amountOut_lt: BigInt
  amountOut_gte: BigInt
  amountOut_lte: BigInt
  amountOut_in: [BigInt!]
  amountOut_not_in: [BigInt!]
  amountOutUSD: BigDecimal
  amountOutUSD_not: BigDecimal
  amountOutUSD_gt: BigDecimal
  amountOutUSD_lt: BigDecimal
  amountOutUSD_gte: BigDecimal
  amountOutUSD_lte: BigDecimal
  amountOutUSD_in: [BigDecimal!]
  amountOutUSD_not_in: [BigDecimal!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: LiquidityPool_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Swap_filter]
  or: [Swap_filter]
}

enum Swap_orderBy {
  id
  hash
  logIndex
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  to
  from
  blockNumber
  timestamp
  tokenIn
  tokenIn__id
  tokenIn__name
  tokenIn__symbol
  tokenIn__decimals
  tokenIn__lastPriceUSD
  tokenIn__lastPriceBlockNumber
  amountIn
  amountInUSD
  tokenOut
  tokenOut__id
  tokenOut__name
  tokenOut__symbol
  tokenOut__decimals
  tokenOut__lastPriceUSD
  tokenOut__lastPriceBlockNumber
  amountOut
  amountOutUSD
  pool
  pool__id
  pool__name
  pool__symbol
  pool__isSingleSided
  pool__createdTimestamp
  pool__createdBlockNumber
  pool__totalValueLockedUSD
  pool__cumulativeSupplySideRevenueUSD
  pool__cumulativeProtocolSideRevenueUSD
  pool__cumulativeTotalRevenueUSD
  pool__cumulativeVolumeUSD
  pool__outputTokenSupply
  pool__outputTokenPriceUSD
  pool__stakedOutputTokenAmount
}

type Token {
  """ Smart contract address of the token """
  id: ID!
  """ Name of the token, mirrored from the smart contract """
  name: String!
  """ Symbol of the token, mirrored from the smart contract """
  symbol: String!
  """ The number of decimal places this token uses, default to 18 """
  decimals: Int!
  """ Optional field to track the price of a token, mostly for caching purposes 
  """
  lastPriceUSD: BigDecimal
  """ Optional field to track the block number of the last token price """
  lastPriceBlockNumber: BigInt
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  lastPriceUSD: BigDecimal
  lastPriceUSD_not: BigDecimal
  lastPriceUSD_gt: BigDecimal
  lastPriceUSD_lt: BigDecimal
  lastPriceUSD_gte: BigDecimal
  lastPriceUSD_lte: BigDecimal
  lastPriceUSD_in: [BigDecimal!]
  lastPriceUSD_not_in: [BigDecimal!]
  lastPriceBlockNumber: BigInt
  lastPriceBlockNumber_not: BigInt
  lastPriceBlockNumber_gt: BigInt
  lastPriceBlockNumber_lt: BigInt
  lastPriceBlockNumber_gte: BigInt
  lastPriceBlockNumber_lte: BigInt
  lastPriceBlockNumber_in: [BigInt!]
  lastPriceBlockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  name
  symbol
  decimals
  lastPriceUSD
  lastPriceBlockNumber
}

type UsageMetricsDailySnapshot {
  """ ID is # of days since Unix epoch time """
  id: ID!
  """ Protocol this snapshot is associated with """
  protocol: DexAmmProtocol!
  """ Number of unique daily active users """
  dailyActiveUsers: Int!
  """ Number of cumulative unique users """
  cumulativeUniqueUsers: Int!
  """ Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. 
  """
  dailyTransactionCount: Int!
  """ Total number of deposits (add liquidity) in a day """
  dailyDepositCount: Int!
  """ Total number of withdrawals (remove liquidity) in a day """
  dailyWithdrawCount: Int!
  """ Total number of trades (swaps) in a day """
  dailySwapCount: Int!
  """ Total number of pools """
  totalPoolCount: Int!
  """ Block number of this snapshot """
  blockNumber: BigInt!
  """ Timestamp of this snapshot """
  timestamp: BigInt!
}

input UsageMetricsDailySnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  dailyActiveUsers: Int
  dailyActiveUsers_not: Int
  dailyActiveUsers_gt: Int
  dailyActiveUsers_lt: Int
  dailyActiveUsers_gte: Int
  dailyActiveUsers_lte: Int
  dailyActiveUsers_in: [Int!]
  dailyActiveUsers_not_in: [Int!]
  cumulativeUniqueUsers: Int
  cumulativeUniqueUsers_not: Int
  cumulativeUniqueUsers_gt: Int
  cumulativeUniqueUsers_lt: Int
  cumulativeUniqueUsers_gte: Int
  cumulativeUniqueUsers_lte: Int
  cumulativeUniqueUsers_in: [Int!]
  cumulativeUniqueUsers_not_in: [Int!]
  dailyTransactionCount: Int
  dailyTransactionCount_not: Int
  dailyTransactionCount_gt: Int
  dailyTransactionCount_lt: Int
  dailyTransactionCount_gte: Int
  dailyTransactionCount_lte: Int
  dailyTransactionCount_in: [Int!]
  dailyTransactionCount_not_in: [Int!]
  dailyDepositCount: Int
  dailyDepositCount_not: Int
  dailyDepositCount_gt: Int
  dailyDepositCount_lt: Int
  dailyDepositCount_gte: Int
  dailyDepositCount_lte: Int
  dailyDepositCount_in: [Int!]
  dailyDepositCount_not_in: [Int!]
  dailyWithdrawCount: Int
  dailyWithdrawCount_not: Int
  dailyWithdrawCount_gt: Int
  dailyWithdrawCount_lt: Int
  dailyWithdrawCount_gte: Int
  dailyWithdrawCount_lte: Int
  dailyWithdrawCount_in: [Int!]
  dailyWithdrawCount_not_in: [Int!]
  dailySwapCount: Int
  dailySwapCount_not: Int
  dailySwapCount_gt: Int
  dailySwapCount_lt: Int
  dailySwapCount_gte: Int
  dailySwapCount_lte: Int
  dailySwapCount_in: [Int!]
  dailySwapCount_not_in: [Int!]
  totalPoolCount: Int
  totalPoolCount_not: Int
  totalPoolCount_gt: Int
  totalPoolCount_lt: Int
  totalPoolCount_gte: Int
  totalPoolCount_lte: Int
  totalPoolCount_in: [Int!]
  totalPoolCount_not_in: [Int!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UsageMetricsDailySnapshot_filter]
  or: [UsageMetricsDailySnapshot_filter]
}

enum UsageMetricsDailySnapshot_orderBy {
  id
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  dailyActiveUsers
  cumulativeUniqueUsers
  dailyTransactionCount
  dailyDepositCount
  dailyWithdrawCount
  dailySwapCount
  totalPoolCount
  blockNumber
  timestamp
}

type UsageMetricsHourlySnapshot {
  """ { # of hours since Unix epoch time } """
  id: ID!
  """ Protocol this snapshot is associated with """
  protocol: DexAmmProtocol!
  """ Number of unique hourly active users """
  hourlyActiveUsers: Int!
  """ Number of cumulative unique users """
  cumulativeUniqueUsers: Int!
  """ Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. 
  """
  hourlyTransactionCount: Int!
  """ Total number of deposits (add liquidity) in an hour """
  hourlyDepositCount: Int!
  """ Total number of withdrawals (remove liquidity) in an hour """
  hourlyWithdrawCount: Int!
  """ Total number of trades (swaps) in an hour """
  hourlySwapCount: Int!
  """ Block number of this snapshot """
  blockNumber: BigInt!
  """ Timestamp of this snapshot """
  timestamp: BigInt!
}

input UsageMetricsHourlySnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  hourlyActiveUsers: Int
  hourlyActiveUsers_not: Int
  hourlyActiveUsers_gt: Int
  hourlyActiveUsers_lt: Int
  hourlyActiveUsers_gte: Int
  hourlyActiveUsers_lte: Int
  hourlyActiveUsers_in: [Int!]
  hourlyActiveUsers_not_in: [Int!]
  cumulativeUniqueUsers: Int
  cumulativeUniqueUsers_not: Int
  cumulativeUniqueUsers_gt: Int
  cumulativeUniqueUsers_lt: Int
  cumulativeUniqueUsers_gte: Int
  cumulativeUniqueUsers_lte: Int
  cumulativeUniqueUsers_in: [Int!]
  cumulativeUniqueUsers_not_in: [Int!]
  hourlyTransactionCount: Int
  hourlyTransactionCount_not: Int
  hourlyTransactionCount_gt: Int
  hourlyTransactionCount_lt: Int
  hourlyTransactionCount_gte: Int
  hourlyTransactionCount_lte: Int
  hourlyTransactionCount_in: [Int!]
  hourlyTransactionCount_not_in: [Int!]
  hourlyDepositCount: Int
  hourlyDepositCount_not: Int
  hourlyDepositCount_gt: Int
  hourlyDepositCount_lt: Int
  hourlyDepositCount_gte: Int
  hourlyDepositCount_lte: Int
  hourlyDepositCount_in: [Int!]
  hourlyDepositCount_not_in: [Int!]
  hourlyWithdrawCount: Int
  hourlyWithdrawCount_not: Int
  hourlyWithdrawCount_gt: Int
  hourlyWithdrawCount_lt: Int
  hourlyWithdrawCount_gte: Int
  hourlyWithdrawCount_lte: Int
  hourlyWithdrawCount_in: [Int!]
  hourlyWithdrawCount_not_in: [Int!]
  hourlySwapCount: Int
  hourlySwapCount_not: Int
  hourlySwapCount_gt: Int
  hourlySwapCount_lt: Int
  hourlySwapCount_gte: Int
  hourlySwapCount_lte: Int
  hourlySwapCount_in: [Int!]
  hourlySwapCount_not_in: [Int!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UsageMetricsHourlySnapshot_filter]
  or: [UsageMetricsHourlySnapshot_filter]
}

enum UsageMetricsHourlySnapshot_orderBy {
  id
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  hourlyActiveUsers
  cumulativeUniqueUsers
  hourlyTransactionCount
  hourlyDepositCount
  hourlyWithdrawCount
  hourlySwapCount
  blockNumber
  timestamp
}

type Withdraw implements Event {
  """ withdraw-{ Transaction hash }-{ Log index }"""
  id: ID!
  """ Transaction hash of the transaction that emitted this event """
  hash: String!
  """ Event log index. For transactions that don't emit event, create arbitrary index starting from 0 
  """
  logIndex: Int!
  """ The protocol this transaction belongs to """
  protocol: DexAmmProtocol!
  """ Address that received the tokens """
  to: String!
  """ Address that sent the tokens """
  from: String!
  """ Block number of this event """
  blockNumber: BigInt!
  """ Timestamp of this event """
  timestamp: BigInt!
  """ Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool 
  """
  inputTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """ Output token of the pool (not output token of the event/transaction). E.g. the UNI-LP token 
  """
  outputToken: Token
  """ Amount of input tokens in the token's native unit """
  inputTokenAmounts: [BigInt!]!
  """ Amount of output tokens in the token's native unit """
  outputTokenAmount: BigInt
  """ USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool) 
  """
  amountUSD: BigDecimal!
  """ The pool involving this transaction """
  pool: LiquidityPool!
}

input Withdraw_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_gt: String
  hash_lt: String
  hash_gte: String
  hash_lte: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_contains_nocase: String
  hash_not_contains: String
  hash_not_contains_nocase: String
  hash_starts_with: String
  hash_starts_with_nocase: String
  hash_not_starts_with: String
  hash_not_starts_with_nocase: String
  hash_ends_with: String
  hash_ends_with_nocase: String
  hash_not_ends_with: String
  hash_not_ends_with_nocase: String
  logIndex: Int
  logIndex_not: Int
  logIndex_gt: Int
  logIndex_lt: Int
  logIndex_gte: Int
  logIndex_lte: Int
  logIndex_in: [Int!]
  logIndex_not_in: [Int!]
  protocol: String
  protocol_not: String
  protocol_gt: String
  protocol_lt: String
  protocol_gte: String
  protocol_lte: String
  protocol_in: [String!]
  protocol_not_in: [String!]
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_: DexAmmProtocol_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  inputTokens: [String!]
  inputTokens_not: [String!]
  inputTokens_contains: [String!]
  inputTokens_contains_nocase: [String!]
  inputTokens_not_contains: [String!]
  inputTokens_not_contains_nocase: [String!]
  inputTokens_: Token_filter
  outputToken: String
  outputToken_not: String
  outputToken_gt: String
  outputToken_lt: String
  outputToken_gte: String
  outputToken_lte: String
  outputToken_in: [String!]
  outputToken_not_in: [String!]
  outputToken_contains: String
  outputToken_contains_nocase: String
  outputToken_not_contains: String
  outputToken_not_contains_nocase: String
  outputToken_starts_with: String
  outputToken_starts_with_nocase: String
  outputToken_not_starts_with: String
  outputToken_not_starts_with_nocase: String
  outputToken_ends_with: String
  outputToken_ends_with_nocase: String
  outputToken_not_ends_with: String
  outputToken_not_ends_with_nocase: String
  outputToken_: Token_filter
  inputTokenAmounts: [BigInt!]
  inputTokenAmounts_not: [BigInt!]
  inputTokenAmounts_contains: [BigInt!]
  inputTokenAmounts_contains_nocase: [BigInt!]
  inputTokenAmounts_not_contains: [BigInt!]
  inputTokenAmounts_not_contains_nocase: [BigInt!]
  outputTokenAmount: BigInt
  outputTokenAmount_not: BigInt
  outputTokenAmount_gt: BigInt
  outputTokenAmount_lt: BigInt
  outputTokenAmount_gte: BigInt
  outputTokenAmount_lte: BigInt
  outputTokenAmount_in: [BigInt!]
  outputTokenAmount_not_in: [BigInt!]
  amountUSD: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_lt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_not_in: [BigDecimal!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: LiquidityPool_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Withdraw_filter]
  or: [Withdraw_filter]
}

enum Withdraw_orderBy {
  id
  hash
  logIndex
  protocol
  protocol__id
  protocol__name
  protocol__slug
  protocol__schemaVersion
  protocol__subgraphVersion
  protocol__methodologyVersion
  protocol__network
  protocol__type
  protocol__totalValueLockedUSD
  protocol__protocolControlledValueUSD
  protocol__cumulativeVolumeUSD
  protocol__cumulativeSupplySideRevenueUSD
  protocol__cumulativeProtocolSideRevenueUSD
  protocol__cumulativeTotalRevenueUSD
  protocol__cumulativeUniqueUsers
  protocol__totalPoolCount
  protocol___regenesis
  to
  from
  blockNumber
  timestamp
  inputTokens
  outputToken
  outputToken__id
  outputToken__name
  outputToken__symbol
  outputToken__decimals
  outputToken__lastPriceUSD
  outputToken__lastPriceBlockNumber
  inputTokenAmounts
  outputTokenAmount
  amountUSD
  pool
  pool__id
  pool__name
  pool__symbol
  pool__isSingleSided
  pool__createdTimestamp
  pool__createdBlockNumber
  pool__totalValueLockedUSD
  pool__cumulativeSupplySideRevenueUSD
  pool__cumulativeProtocolSideRevenueUSD
  pool__cumulativeTotalRevenueUSD
  pool__cumulativeVolumeUSD
  pool__outputTokenSupply
  pool__outputTokenPriceUSD
  pool__stakedOutputTokenAmount
}

"""  Used to keep track of the price of Ether/TVL in USD, pool deposit count, and total unique users 
"""
type _HelperStore {
  id: ID!
  """ price of ETH/TVL in USD """
  valueDecimal: BigDecimal
  """ # of deposits, # of unique users """
  valueInt: Int
}

input _HelperStore_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  valueDecimal: BigDecimal
  valueDecimal_not: BigDecimal
  valueDecimal_gt: BigDecimal
  valueDecimal_lt: BigDecimal
  valueDecimal_gte: BigDecimal
  valueDecimal_lte: BigDecimal
  valueDecimal_in: [BigDecimal!]
  valueDecimal_not_in: [BigDecimal!]
  valueInt: Int
  valueInt_not: Int
  valueInt_gt: Int
  valueInt_lt: Int
  valueInt_gte: Int
  valueInt_lte: Int
  valueInt_in: [Int!]
  valueInt_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [_HelperStore_filter]
  or: [_HelperStore_filter]
}

enum _HelperStore_orderBy {
  id
  valueDecimal
  valueInt
}

type _LiquidityPoolAmount {
  """ Smart contract address of the pool """
  id: ID!
  """ Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool 
  """
  inputTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """ Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. 
  """
  inputTokenBalances: [BigDecimal!]!
  tokenPrices: [BigDecimal!]!
}

input _LiquidityPoolAmount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  inputTokens: [String!]
  inputTokens_not: [String!]
  inputTokens_contains: [String!]
  inputTokens_contains_nocase: [String!]
  inputTokens_not_contains: [String!]
  inputTokens_not_contains_nocase: [String!]
  inputTokens_: Token_filter
  inputTokenBalances: [BigDecimal!]
  inputTokenBalances_not: [BigDecimal!]
  inputTokenBalances_contains: [BigDecimal!]
  inputTokenBalances_contains_nocase: [BigDecimal!]
  inputTokenBalances_not_contains: [BigDecimal!]
  inputTokenBalances_not_contains_nocase: [BigDecimal!]
  tokenPrices: [BigDecimal!]
  tokenPrices_not: [BigDecimal!]
  tokenPrices_contains: [BigDecimal!]
  tokenPrices_contains_nocase: [BigDecimal!]
  tokenPrices_not_contains: [BigDecimal!]
  tokenPrices_not_contains_nocase: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [_LiquidityPoolAmount_filter]
  or: [_LiquidityPoolAmount_filter]
}

enum _LiquidityPoolAmount_orderBy {
  id
  inputTokens
  inputTokenBalances
  tokenPrices
}

""" This is used to keep tract of the derived price of tokens in ethereum and the whitelisted pools to which it belongs
"""
type _TokenWhitelist {
  """ Token Address """
  id: ID!
  """ pools token is in that are white listed for USD pricing """
  whitelistPools(skip: Int = 0, first: Int = 100, orderBy: LiquidityPool_orderBy, orderDirection: OrderDirection, where: LiquidityPool_filter): [LiquidityPool!]!
}

input _TokenWhitelist_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  whitelistPools: [String!]
  whitelistPools_not: [String!]
  whitelistPools_contains: [String!]
  whitelistPools_contains_nocase: [String!]
  whitelistPools_not_contains: [String!]
  whitelistPools_not_contains_nocase: [String!]
  whitelistPools_: LiquidityPool_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [_TokenWhitelist_filter]
  or: [_TokenWhitelist_filter]
}

enum _TokenWhitelist_orderBy {
  id
  whitelistPools
}